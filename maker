#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Copyright CEA (2000-2005)
#
#  This software and supporting documentation were developed by
#      CEA/DSV/SHFJ
#      4 place du General Leclerc
#      91401 Orsay cedex
#      France
#
# This software is governed by the CeCILL license version 2 under 
# French law and abiding by the rules of distribution of free software.
# You can  use, modify and/or redistribute the software under the 
# terms of the CeCILL license version 2 as circulated by CEA, CNRS
# and INRIA at the following URL "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# knowledge of the CeCILL license version 2 and that you accept its terms.

version = '2.0'

# -----------------------------------------------------------------------------
#
#                   +---------------------+
#                   |        VPATH        |
#   **************  |                     |  ***************
#   * build tree *  |    +-----------+    |  * source tree *
#   **************  |    |           |    |  ***************
#                   |    +-----------+    |
#                   |       /     \       |
#                   |      /       \      |
#                   |     /         \     |
#                   |    /           \    V
#                 +-----------+ +-----------+
#              +->|     .     | | configure |--+
#              |  +-----------+ +-----------+  |
#              |       /               \       |
#        QPATH |      /                 \      | PPATH
#              |     /                   \     |
#              |    /                     \    V
#            +-----------+           +-----------+
#            |  Makefile |           |  project  |
#            +-----------+           +-----------+
#                 /                         \
#                /                           \
#               /                             \
#              /                               \
#       +-----------+                     +-----------+
#       |   object  |                     |   source  |
#       +-----------+                     +-----------+
#
# -----------------------------------------------------------------------------

import string
import sys
import os
import types
import signal
import errno
import glob
import copy
import distutils.spawn
import operator

# re module is buggy on RHEL 3 (Python 2.2.3) and Darwin (Python 2.2.?) so
# we use pre, but at some point we actually need re module (because pre is
# buggy too), so we use both:
# - re is the 'common' regex module: pre with buggy Pythons, re on other
#  platforms
# - re2 is always the actual re module so on all but buggy Pythons it's the
#   same as re
# OK it's quite stupid...
if sys.version_info[0] == 2 and sys.version_info[1] < 3:
  import re
  re2 = re
  import pre
  re = pre
else:
  import re
  re2 = re

dirSeparator = '/'
se = os.path.join( os.path.dirname( sys.argv[0] ), 'sip4make.py' )
if os.path.exists( se ):
  if sys.platform[:3] == 'win':
    sip_executable = sys.executable.replace( '\\', '/' ) + ' "' + se + '"'
  else:
    sip_executable = sys.executable + ' "' + se + '"'
else:
  se = os.path.join( os.path.dirname( os.path.realpath( sys.argv[0] ) ),
                     'sip4make.py' )
  if os.path.exists( se ):
    if sys.platform[:3] == 'win':
      sip_executable = sys.executable.replace( '\\', '/' ) + ' "' + se + '"'
    else:
      sip_executable = sys.executable + ' "' + se + '"'
  else:
    se = distutils.spawn.find_executable( 'sip4makee.py' )
    if se:
      if sys.platform[:3] == 'win':
        sip_executable = sys.executable.replace( '\\', '/' ) + ' "' + se + '"'
      else:
        sip_executable = sys.executable + ' "' + se + '"'
    else:
      print 'warning: no sip4make.py found, using regular sip without caching'
      sip_executable = 'sip'

def exit_handler( number, frame ):
  sys.exit(errno.EINTR)

signal.signal( signal.SIGINT, exit_handler )

# -----------------------------------------------------------------------------
#
# error message formatting
#
# -----------------------------------------------------------------------------

def warning(message, filename=None, line=None):
  if filename:
    if line:
      sys.stderr.write(filename + ':' + str(line) + ': ' + message + '\n')
    else:
      sys.stderr.write(filename + ': ' + message + '\n')
  else:
    sys.stderr.write(os.path.basename(sys.argv[0]) + ': ' + message + '\n')


# -----------------------------------------------------------------------------
#
# string facilities
#
# -----------------------------------------------------------------------------

# index of the first difference between strings
def diffindex(s1, s2):
  for i in range(min(len(s1), len(s2))):
    if s1[i] != s2[i]:
      return i
  return None


# -----------------------------------------------------------------------------
#
# path utilities
#
# -----------------------------------------------------------------------------

#  inverse  d'un chemin de fichier, ne marche _pas_ avec '..' ou des symlinks
def walkback(f):
  w = None
  d = os.path.dirname(f)
  if d and d != f:
    ### ne marche pas le cas d'un chemin contenant '..'
    w = '..'
    f = d
    d = os.path.dirname(f)
    while d and d != f:
      ### ne marche pas le cas d'un chemin contenant '..'
      w = os.path.join('..', w)
      f = d
      d = os.path.dirname(f)
    if d == f:
      w = None
  return w

#  inverse  du chemin du fichier en argument + VPATH
def fvpath(v, f):
  w = walkback(f)
  if v:
    if w:
      v = os.path.join(w, v)
    return v
  return w

# VPATH + PPATH + chemin du fichier en argument
def vppath(v, p, f=None):
  if p:
    if f:
      p = os.path.join(p, f)
    else:
      p = f
    if v:
      if p:
        v = os.path.join(v, p)
    else:
      v = p
    return v

#  inverse  de PPATH + VPATH + PPATH + chemin du fichier en argument
def qvppath(v, p, f=None):
  if v and p:
    v = os.path.join(walkback(p), v)
    v = os.path.join(v, p)
  return os.path.join(v, f)


# on windows, paths containing \ are interpreted and removed by shells...
def unescape( p ):
  if sys.platform == 'win32':
    return p.replace( '\\', '\\\\' )
  else:
    return p

def unixpath( p ):
  if sys.platform == 'win32':
    if p[1:3] == ':\\':
      q = '/' + p[0] + '/' + p[3:]
      return q.replace( '\\', '/' )
    else:
      return p.replace( '\\', '/' )
  else:
    return p


# -----------------------------------------------------------------------------
#
# simulate static methods
#
# -----------------------------------------------------------------------------

class Static:
  def __init__(self, function):
    self.function = function

  def __call__(self, *args, **kwargs):
    return self.function(*args, **kwargs)


# -----------------------------------------------------------------------------
#
# known compilers
#
#        Types de compilateurs support�, avec des dictionnaires de noms pour
#         les d�igner dans les fichiers de projet - compilateurs commerciaux
#         UNIX et Windows, GCC, et MPI pour le parall�isme.
#
# -----------------------------------------------------------------------------

class Compiler:

  vendor   = 0x00ff
  mpi      = 0x0200 # MPICH compiler
  gnu      = 0x0300 # GCC
  apple    = 0x0400 # GCC modified by Apple
  intel    = 0x0500 # Intel C++
  sun      = 0x0600 # Sun WorkShop / Forte Developer
  mips     = 0x0700 # MIPSpro
  compaq   = 0x0800 # Compaq C++
  msvc     = 0x0900 # Microsoft Visual C/C++
  borland  = 0x0a00 # Borland C++
  mars     = 0x0b00 # Digital Mars / Symantec / Zortech

  # Traduit le code interne d�ignant un compilateur vers le nom
  # correspondant utilis�dans les fichiers de projet.
  __table = {
    mpi:        'mpi',
    gnu:        'gcc',
    apple:      'apple',
    sun:        'cc',
    mips:       'cc',
    compaq:     'cxx',
    msvc:       'msvc',
    borland:    'borland',
    mars:       'dmc',
  }

  def __name(compiler):
    return Compiler.__table.get(compiler)

  name = Static(__name)

  # Renvoie la liste des compilateurs support�.
  def __names():
    return Compiler.__table.values()

  names = Static(__names)


# -----------------------------------------------------------------------------
#
# known systems
#
#         Liste des syst�es d'exploitation support�, avec des dictionnaires de
#         noms pour les d�igner dans les fichiers de projet.
#
# -----------------------------------------------------------------------------

class OS:

  linux   = 0x0001
  solaris = 0x0002
  irix    = 0x0004
  tru64   = 0x0008
  win32   = 0x0010
  darwin  = 0x0020
  cygwin  = 0x0040

  def __str__(self):
    return self.name(self._system)

  # Traduit le nom du syst�e d'exploitation renvoy�par sys.platform vers
  # le code interne correspondant.
  def __parse(name):
    if name[:5] == 'linux':
      return OS.linux
    if name == 'sunos5':
      return OS.solaris
    if name[:4] == 'irix':
      return OS.irix
    if name[:4] == 'osf1':
      return OS.tru64
    if name == 'win32':
      return OS.win32
    if name[:6] == 'darwin':
      return OS.darwin
    if name == 'cygwin':
      return OS.cygwin
    return None

  parse = Static(__parse)

  # Traduit le code interne d�ignant un syst�e d'exploitation vers le nom
  # correspondant utilis�dans les fichiers de projet.
  __table = {
    linux:    'linux',
    solaris:  'solaris',
    irix:     'irix',
    tru64:    'tru64',
    win32:    'win32',
    darwin:   'darwin',
    cygwin:   'cygwin',
  }

  def __name(os):
    return OS.__table.get(os)

  name = Static(__name)

  # Renvoie la liste des syst�es support�.
  def __names():
    return OS.__table.values()

  names = Static(__names)

  # Renvoie le compilateur natif d'un syst�e d'exploitation.
  __native = {
    linux:    Compiler.gnu,
    solaris:  Compiler.sun,
    irix:     Compiler.mips,
    tru64:    Compiler.compaq,
    win32:    Compiler.msvc,
    darwin:   Compiler.gnu,
    cygwin:   Compiler.gnu,
  }
  def __compiler(os):
    return OS.__native.get(os)

  compiler = Static(__compiler)


# -----------------------------------------------------------------------------
#
# platform specs
#
#         Pour chaque platforme, une liste d'options pour les r�les de
#         construction des cibles.
#
# -----------------------------------------------------------------------------

class Configuration:

  __linux_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-Wall -W',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         '-fPIC',
    'CXX':                  'g++',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-D_REENTRANT',
    'CXXFLAGS_SHLIB':       '-fPIC',
    'LFLAGS':               '-Wl,-export-dynamic',
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.so',
  }

  __linux_icc = {
    'CC':                   'icc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       None,
    'CFLAGS_WARN_OFF':      '-w',
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         '-KPIC',
    'CXX':                  'icpc',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     None,
    'CXXFLAGS_WARN_OFF':    '-w',
    'CXXFLAGS_THREAD':      '-D_REENTRANT',
    'CXXFLAGS_SHLIB':       '-KPIC',
    'LFLAGS':               None,
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Qoption,ld,-soname,',
    'LINKCC':               'icc',
    'LINKCXX':              'icpc',
    'LINKCC_SHARED':        'icc',
    'LINKCXX_SHARED':       'icpc',
    'EXTENSION_SHLIB':      '.so',
  }

  __solaris_cc = {
    'CC':                   'cc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O',
    'CFLAGS_DEPS':          '-xM',
    'CFLAGS_WARN_ON':       None,
    'CFLAGS_WARN_OFF':      '-w',
    'CFLAGS_THREAD':        '-mt',
    'CFLAGS_SHLIB':         '-KPIC',
    'CXX':                  'CC',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O',
    'CXXFLAGS_DEPS':        '-xM',
    'CXXFLAGS_WARN_ON':     '+w',
    'CXXFLAGS_WARN_OFF':    '-w',
    'CXXFLAGS_THREAD':      '-mt',
    'CXXFLAGS_SHLIB':       '-KPIC',
    'LFLAGS':                None,
    'LFLAGS_THREAD':        '-mt',
    'LFLAGS_SHLIB':         '-G',
    'LFLAGS_SONAME':        '-h ',
    'LINKCC':               'cc',
    'LINKCXX':              'CC',
    'LINKCC_SHARED':        'cc',
    'LINKCXX_SHARED':       'CC',
    'EXTENSION_SHLIB':      '.so',
  }

  __solaris_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-Wall -W -Wno-unknown-pragmas',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         '-fPIC',
    'CXX':                  'g++',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W -Wno-unknown-pragmas',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-D_REENTRANT',
    'CXXFLAGS_SHLIB':       '-fPIC',
    'LFLAGS':               '-Wl,-export-dynamic',
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-h ',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.so',
  }

  __irix_cc = {
    'CC':                   'cc',
    'CFLAGS':               '-n32',
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-fullwarn',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        None,
    'CFLAGS_SHLIB':         None,
    'CXX':                  'CC',
    'CXXFLAGS':             '-n32 -LANG:ansi-for-init-scope=ON:bool=ON',
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-fullwarn',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      None,
    'CXXFLAGS_SHLIB':       None,
    'LFLAGS':               '-n32',
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'cc',
    'LINKCXX':              'CC',
    'LINKCC_SHARED':        'cc',
    'LINKCXX_SHARED':       'CC',
    'EXTENSION_SHLIB':      '.so',
  }

  __irix_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_WARN_ON':       '-Wall -W -Wno-unknown-pragmas',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         '-fPIC',
    'CXX':                  'g++',
    'CXXFLAGS':              None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W -Wno-unknown-pragmas',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-D_REENTRANT',
    'CXXFLAGS_SHLIB':       '-fPIC',
    'LFLAGS':               '-Wl,-export-dynamic',
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.so',
  }

  __tru64_cxx = {
    'CC':                   'cxx',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       None,
    'CFLAGS_WARN_OFF':       None,
    'CFLAGS_THREAD':        '-pthread',
    'CFLAGS_SHLIB':         None,
    'CXX':                  'cxx',
    'CXXFLAGS':             '-x cxx',
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     None,
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-pthread',
    'CXXFLAGS_SHLIB':       None,
    'LFLAGS':               None,
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-G',
    'LFLAGS_SONAME':        '-h ',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.so',
  }

  __tru64_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-Wall -W',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-pthread',
    'CFLAGS_SHLIB':         '-fPIC',
    'CXX':                  'g++',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-pthread',
    'CXXFLAGS_SHLIB':       '-fPIC',
    'LFLAGS':               '-Wl,-export-dynamic',
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.so',
  }

  __win32_msvc = {
    ### �completer
  }

  __win32_borland = {
    ### �completer
  }
  
  __win32_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-Wall -W',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         None,
    'CXX':                  'g++',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-D_REENTRANT -mthreads',
    'CXXFLAGS_SHLIB':       None,
    'LFLAGS':               '-Wl,--enable-runtime-pseudo-reloc',
    'LFLAGS_THREAD':        '-mthreads',
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.dll',
  }

  __darwin_gnu = {
   'CC':                    'cc',
   'CFLAGS':                None,
   'CFLAGS_DEBUG':          '-g',
   'CFLAGS_RELEASE':        '-O2',
   'CFLAGS_DEPS':           '-M',
   'CFLAGS_WARN_ON':        '-Wall -W',
   'CFLAGS_WARN_OFF':       None,
   'CFLAGS_THREAD':         '-D_REENTRANT',
   'CFLAGS_SHLIB':          None,
   'CXX':                   'c++',
   'CXXFLAGS':              None,
   'CXXFLAGS_DEBUG':        '-g',
   'CXXFLAGS_RELEASE':      '-O2',
   'CXXFLAGS_DEPS':         '-M',
   'CXXFLAGS_WARN_ON':      '-Wall -W',
   'CXXFLAGS_WARN_OFF':     None,
   'CXXFLAGS_THREAD':       '-D_REENTRANT',
   'CXXFLAGS_SHLIB':        '-dynamic',
   'LFLAGS':                None,
   'LFLAGS_THREAD':         None,
   'LFLAGS_SHLIB':          '-dynamiclib -Wl,-single_module',
   'LFLAGS_SONAME':         '-Wl,-install_name -Wl,',
   'LINKCC':                'cc',
   'LINKCXX':               'c++',
   'LINKCC_SHARED':         'cc',
   'LINKCXX_SHARED':        'c++',
   'LFLAGS_BUNDLE':         '-bundle',
   'EXTENSION_SHLIB':       '.dylib',
   'EXTENSION_BUNDLE':      '.so',
  }

  __cygwin_gnu = {
    'CC':                   'gcc',
    'CFLAGS':               None,
    'CFLAGS_DEBUG':         '-g',
    'CFLAGS_RELEASE':       '-O2',
    'CFLAGS_DEPS':          '-M',
    'CFLAGS_WARN_ON':       '-Wall -W',
    'CFLAGS_WARN_OFF':      None,
    'CFLAGS_THREAD':        '-D_REENTRANT',
    'CFLAGS_SHLIB':         None,
    'CXX':                  'g++',
    'CXXFLAGS':             None,
    'CXXFLAGS_DEBUG':       '-g',
    'CXXFLAGS_RELEASE':     '-O2',
    'CXXFLAGS_DEPS':        '-M',
    'CXXFLAGS_WARN_ON':     '-Wall -W',
    'CXXFLAGS_WARN_OFF':    None,
    'CXXFLAGS_THREAD':      '-D_REENTRANT',
    'CXXFLAGS_SHLIB':       None,
    'LFLAGS':               None,
    'LFLAGS_THREAD':        None,
    'LFLAGS_SHLIB':         '-shared',
    'LFLAGS_SONAME':        '-Wl,-soname,',
    'LINKCC':               'gcc',
    'LINKCXX':              'g++',
    'LINKCC_SHARED':        'gcc',
    'LINKCXX_SHARED':       'g++',
    'EXTENSION_SHLIB':      '.dll',
  }

  __table = {
    OS.linux: {
      Compiler.vendor:      __linux_gnu,
      Compiler.gnu:         __linux_gnu,
      Compiler.intel:       __linux_icc,
    },
    OS.solaris: {
      Compiler.vendor:      __solaris_cc,
      Compiler.sun:         __solaris_cc,
      Compiler.gnu:         __solaris_gnu,
    },
    OS.irix: {
      Compiler.vendor:      __irix_cc,
      Compiler.mips:        __irix_cc,
      Compiler.gnu:         __irix_gnu,
    },
    OS.tru64: {
      Compiler.vendor:      __tru64_cxx,
      Compiler.compaq:      __tru64_cxx,
      Compiler.gnu:         __tru64_gnu,
    },
    OS.win32: {
      Compiler.vendor:      __win32_msvc,
      Compiler.msvc:        __win32_msvc,
      Compiler.borland:     __win32_borland,
      Compiler.gnu:         __win32_gnu,
    },
    OS.darwin: {
      Compiler.vendor:      __darwin_gnu,
      Compiler.gnu:         __darwin_gnu,
    },
    OS.cygwin: {
      Compiler.vendor:      __cygwin_gnu,
      Compiler.gnu:         __cygwin_gnu,
    },
  }

  # Renvoie les sp�ifications propres �la plateforme pass� en argument et
  # None si cette plateforme n'est pas support� (par exemple compilateur Compaq
  # sur syst�e Windows)
  def __specs(platform):
    system = Configuration.__table.get(platform.system())
    if system:
            return system.get(platform.compiler())
    return None

  specs = Static(__specs)

  def __moc():
    return os.path.join( '$(QTDIR)', 'bin', 'moc' )

  moc = Static(__moc)

  def __qt_version():
    m = os.path.expandvars( Configuration.moc().replace( \
      '(', '' ).replace( ')', '' ) )
    m += ' -v'
    try:
      x = os.popen3( m )
      mout = x[2].read()
    except:
      return [ 3, 0, 0 ] # reasonable default...
    x[0].close()
    x[1].close()
    x[2].close()
    del x
    r = re.match( \
      '^.*\(Qt\s([0-9]+\.[0-9]+\.[0-9]+)[^0-9\)]?[^\)]*\).*$', mout )
    if not r:
      return [ 3, 0, 0 ] # reasonable default...
    return [ int(x) for x in r.group(1).split( '.' ) ]

  qt_version = Static(__qt_version)

# -----------------------------------------------------------------------------
#
# system / compiler combination
#
#         Une plateforme est la combinaison d'un syst�e d'exploitation et d'un
#         compilateur.
#
# -----------------------------------------------------------------------------

class Platform:

  def __init__(self):
    self.__system = OS.parse(sys.platform)
    #if self.__system == OS.win32:
    #  self.__compiler = Compiler.msvc
    #else:
    self.__compiler = Compiler.gnu
    self.__sipversion = None

  def setOptions(self, option):
    if option.system():
      self.__system = option.system()
    if option.compiler():
      self.__compiler = option.compiler()

  def system(self):
    return self.__system

  def systemname(self):
    return OS.name(self.__system)

  def compiler(self):
    return self.__compiler

  def compilername(self):
    return Compiler.name(self.__compiler)

  def sipversion(self):
    if self.__sipversion is None:
      try:
        import sip
        self.__sipversion = ( sip.SIP_VERSION >> 16,
                              ( sip.SIP_VERSION >> 8 ) & 0xff,
                              sip.SIP_VERSION & 0xff )
      except:
        f = os.popen( sip_executable + ' -V' )
        v = f.read()
        f.close()
        v = v.split()[0]
        self.__sipversion = map( lambda x: int( x ), v.split( '.' ) )
    return self.__sipversion

# -----------------------------------------------------------------------------
#
# cache d'informations sur le fichier
#
#         Cette classe représente un fichier. Il s'agit d'un cache qui optimise
#         l'accès à des informations sur ce fichier telles que le suffixe ou le
#         langage utilisé dans les fichiers sources.
#
# -----------------------------------------------------------------------------

class File:

  # type of file
  C   = 0x0001
  Cpp = 0x0002

  # C comments
  __comment1_regex = re.compile('/\*.*?\*/', re.MULTILINE|re.DOTALL)
  # C++ comments
  __comment2_regex = re.compile('//.*\n', re.MULTILINE)

  # cache for accelarating the moc() function
  __moc_cache = {}

  def __init__(self, filename):
    self.__name = filename
    self.__head, tail = os.path.split(filename)
    self.__root, self.__ext = os.path.splitext(tail)

  def name(self):
    return self.__name

  def fullname(self):
    return os.path.join(self.dirname(), self.__root + self.__ext)

  def filename(self):
    return os.path.join(self.__root + self.__ext)

  def dirname(self):
    return self.__head

  def basename(self):
    return self.__root

  def suffix(self):
    return self.__ext

  def lang(self):
    self.suffix()
    if self.suffix() == '.cc' or self.suffix() == '.cpp' \
           or self.suffix() == '.cxx':
      return File.Cpp
    elif self.suffix() == '.c':
      return File.C
    else:
      return None

  def moc(self):
    filename = self.fullname()
    if not self.__moc_cache.has_key(filename):
      try:
        handle = open(filename, 'r')
        contents = ''
        line = handle.readline()
        while line:
          contents = contents + line
          line = handle.readline()
        handle.close()
        lines = re.sub(self.__comment1_regex, '', contents)
        lines = re.sub(self.__comment2_regex, '\n', contents)
        if re.search('(^|\W)(Q_OBJECT)|(Q_COMPONENT)(\W|$)', contents):
          self.__moc_cache[filename] = TRUE
        else:
          self.__moc_cache[filename] = FALSE
      except IOError, (errno, strerror):
        warning(strerror, filename)
        self.__moc_cache[filename] = FALSE
    return self.__moc_cache[filename]


# -----------------------------------------------------------------------------
#
#         � peut �re utile...
#
# -----------------------------------------------------------------------------

FALSE = 0
TRUE = not FALSE


# -----------------------------------------------------------------------------
#
# project
#
#         Cette classe repr�ente un projet. Un projet d�rit la construction
#         d'une cible. Il contient la liste des sources n�essaires, indique les
#         r�les de construction standard �utiliser, ainsi que les options �#         appliquer �ces r�les.
#         La m�hode read() permet de lire un fichier de projet en collaboration
#         avec la classe ProjectFile et de m�oriser les sources et options
#         d�rites dans ce fichier.
#         Une fois lu depuis un fichier, un projet se souvient du nom de ce
#         fichier, accessible par filename(). Par convention les chemins de
#         fichier qui figurent dans le projet sont relatifs au r�ertoire du
#         fichier de projet. Appelons ce r�ertoire PPATH:
#                 PPATH = os.path.dirname(self.filename())
#         D'autre part il est possible de sp�ifier un chemin suppl�entaire
#         que nous appelerons VPATH, �uivalent au VPATH utilis�par make.
#         VPATH permet l'utilisation transparente de projets situ� dans VPATH
#         tout en les nommant par leur chemin relatif �VPATH plut� que
#         d'utiliser le chemin relatif au r�ertoire courant.
#
# -----------------------------------------------------------------------------

class Project:

        app = 0x0010
        lib = 0x0020
        sub = 0x0040
        pak = 0x0080
        bdl = 0x0100        #bundle (MacOS X)
        sip = 0x0200        # sip library (python/PyQt module)
	swig = 0x0300

        debug    = 0x0100
        default  = 0x0200
        optimize = 0x0400

        def __init__(self):
                self.__filename = None
                self.__vpath = None
                self.__binbdir = None
                self.__incbdir = None
                self.__libbdir = None
                self.__compiler = None
                self.__mode = self.default
                self.__warn = TRUE
                self.__thread = FALSE
                self.__cpp = FALSE
                self.__variable = {}
                self.__file_scope_variable = {}
                self.__modules = []
                self.__binfile = None
                self.__incfile = None
                self.__libfile = None
                self.__pyfile = None
                self.__buildmode = None

        def setOptions(self, option):
                if option.mode() == Options.debug:
                        self.__mode = self.debug
                elif option.mode() == Options.optimize:
                        self.__mode = self.optimize
                self.__buildmode = option.buildMode()
                v = option.vpath()
                if v:
                        self.__vpath = os.path.normpath(v)
                b = option.binbdir()
                if b:
                        self.__binbdir = os.path.normpath(b)
                i = option.incbdir()
                if i:
                        self.__incbdir = os.path.normpath(i)
                l = option.libbdir()
                if l:
                        self.__libbdir = os.path.normpath(l)
                l = option.binfile()
                if l:
                        self.__binfile = os.path.normpath(l)
                l = option.incfile()
                if l:
                        self.__incfile = os.path.normpath(l)
                l = option.libfile()
                if l:
                        self.__libfile = os.path.normpath(l)
                l = option.pyfile()
                if l:
                        self.__pyfile = os.path.normpath(l)

        # ???
        def setSpecs(self, platform):
                specs = Configuration.specs(platform)
                if specs == None:
                        s = OS.name(platform.system())
                        c = Compiler.name(platform.compiler())
                        warning('Platform not supported (' + str(s) + '/'+ str(c) + ')')
                        sys.exit(1)
                for key in specs.keys():
                        k = None
                        d = key.rfind('_DEBUG')
                        r = key.rfind('_RELEASE')
                        if key[r:] == '_RELEASE':
                                if not self.__mode == Project.optimize:
                                        continue
                                k = key[:r]
                        elif key[d:] == '_DEBUG':
                                if not self.__mode == Project.debug:
                                        continue
                                k = key[:d]
                        else:
                                k = key
                        if self.__variable.has_key(k):
                                if specs[key]:
                                        self.__variable[k].append(specs[key])
                        else:
                                if specs[key]:
                                        self.__variable[k] = [specs[key]]
                                else:
                                        self.__variable[k] = []

        def buildMode( self ):
          return self.__buildmode

        # VPATH
        def vpath(self):
                return self.__vpath

        # VPATH + PPATH + chemin du fichier en argument
        def vppath(self, f=None):
                p = os.path.dirname(self.filename())
                if p:
                        if f:
                                p = os.path.join(p, f)
                else:
                        p = f
                v = self.__vpath
                if v:
                        if p:
                                v = os.path.join(v, p)
                else:
                        v = p
                return v

        #  inverse  de PPATH + VPATH + PPATH + chemin du fichier en argument
        def qvppath(self, f=None):
                p = os.path.dirname(self.filename())
                if p:
                        if f:
                                p = os.path.join(p, f)
                else:
                        p = f
                v = self.__vpath
                if v:
                        if p:
                                v = os.path.join(v, p)
                else:
                        v = p
                p = os.path.dirname(self.filename())
                while p:
                        ### ca ne marche pas dans tous les cas ?
                        v = os.path.join('..', v)
                        p = os.path.dirname(p)
                return v

        # Lit un fichier de projet en collaboration avec la classe ProjectFile.
        def read(self, filename, platform):
                # corriger le nom du fichier de projet
                self.__filename = os.path.normpath(filename)
                if self.__vpath:
                        filename2 = os.path.join(self.__vpath, filename)
                else:
                          filename2 = filename
                if filename2[-4:] != '.pro' and os.path.exists(filename2 + '.pro'):
                        filename = filename + '.pro'
                # lire le fichier de projet
                file = ProjectFile(filename, self.__vpath, os.getcwd() )
                file.read(self)
                # basculer tout le projet en C++ si un des sources est en C++
                if self.__variable.has_key('SOURCES'):
                        for source in self.__variable['SOURCES']:
                                if source.lang() == File.Cpp:
                                        self.__cpp = TRUE
                                        break
                # corriger incbdir si une directive specifique est donnee dans
                # le fichier projet
                if self.__variable.has_key('INCBDIR'):
                  incbdir = self.__variable['INCBDIR']
                  if len(incbdir) > 1:
                    warning('INCBDIR should have only one value, taking last')
                  if not len(incbdir):
                    self.__incbdir += '/../'
                  else: self.__incbdir += '/../' + incbdir[-1]

        # Les qualificatifs d'une variable sont compar� �la plateforme et
        # aux options courantes. La fonction renvoie TRUE si les qualificatifs
        # s'appliquent et FALSE si un des qualificatifs ne s'applique au cas
        # courant.
        def active_scope(self, scope, variable, platform, profilename, proline):
                if scope in OS.names():
                        if scope == platform.systemname():
                                return TRUE
                elif scope in Compiler.names():
                        if scope == platform.compilername():
                                return TRUE
                elif scope == 'app':
                        return project.template() == Project.app
                elif scope == 'lib':
                        return project.template() == Project.lib
                elif scope == 'mpi':
                        return self.__compiler == Compiler.mpi
                elif scope == 'gcc':
                        return self.__compiler == Compiler.gnu
                elif scope == 'native':
                        return self.__compiler == Compiler.native
                elif scope == 'debug':
                        return self.__mode == Project.debug
                elif scope == 'default':
                        return self.__mode == Project.default
                elif scope == 'release':
                        return self.__mode == Project.optimize
                elif scope == 'thread':
                        return self.__thread
                elif scope == 'warn_on':
                        return self.__warn
                elif scope == 'warn_off':
                        return not self.__warn
                elif scope == 'qt':
                        return FALSE
                elif self.__variable.has_key('CONFIG') and self.__variable['CONFIG'] == scope:
                        return TRUE
                if scope == self.buildMode():
                        return TRUE
                # check use of module
                module = re.compile(r'\s*module\s*\(\s*([^\s\)]*)\s*\)\s*$')
                modmatch = module.match(scope)
                if modmatch:
                        modname = modmatch.group(1)
                        if modname in self.__modules:
                                return TRUE
                return FALSE

        def file_insert(self, variable, operator, value, profilename, proline):
                if operator == '=':
                        self.__variable[variable] = []
                        for filename in value.split():
                                file = File(filename)
                                self.__variable[variable].append(file)
                elif operator == '+=':
                        if not self.__variable.has_key(variable):
                                self.__variable[variable] = []
                        for filename in value.split():
                                file = File(filename)
                                self.__variable[variable].append(file)
                elif operator == '*=':
                        if not self.__variable.has_key(variable):
                                self.__variable[variable] = []
                        for filename in value.split():
                                file = File(filename)
                                if not file in self.__variable[variable]:
                                        self.__variable[variable].append(file)
                elif operator == '-=':
                        if self.__variable.has_key(variable):
                                for filename in value.split():
                                        file = File(filename)
                                        if file in self.__variable[variable]:
                                                self.__variable[variable].remove(file)
                else:
                        warning('unknown operator "' + operator + '"', profilename, proline)
                        sys.exit(1)

        def qualified_insert(self, filename, variable, operator, value, profilename, proline):
                if filename:
                        if not self.__variable.has_key('SOURCES'):
                                warning('filename scope cannot be applied prior to defining SOURCES"', profilename, proline)
                                sys.exit(1)
                if operator == '=':
                        if filename:
                                file = File(filename)
                                if not self.__file_scope_variable.has_key(file):
                                        self.__file_scope_variable[file] = {}
                                self.__file_scope_variable[file][variable] = value.split()
                        else:
                                self.__variable[variable] = value.split()
                                for file in self.__file_scope_variable.keys():
                                        if self.__file_scope_variable[file].has_key(variable):
                                                del self.__file_scope_variable[file][variable]
                elif operator == '+=':
                        if filename:
                                file = File(filename)
                                if not self.__file_scope_variable.has_key(file):
                                        self.__file_scope_variable[file] = {}
                                if self.__file_scope_variable[file].has_key(variable):
                                        self.__file_scope_variable[file][variable] = self.__file_scope_variable[file][variable] + value.split()
                                elif self.__variable.has_key(variable):
                                        self.__file_scope_variable[file][variable] = self.__variable[variable] + value.split()
                                else:
                                        self.__file_scope_variable[file][variable] = value.split()
                        else:
                                if self.__variable.has_key(variable):
                                        self.__variable[variable] = self.__variable[variable] + value.split()
                                else:
                                        self.__variable[variable] = value.split()
                                for file in self.__file_scope_variable.keys():
                                        if self.__file_scope_variable[file].has_key(variable):
                                                self.__file_scope_variable[file][variable] = self.__file_scope_variable[file][variable] + value.split()
                elif operator == '*=':
                        if filename:
                                file = File(filename)
                                if not self.__file_scope_variable.has_key(file):
                                        self.__file_scope_variable[file] = {}
                                if self.__file_scope_variable[file].has_key(variable):
                                        for item in value.split():
                                                if not item in self.__file_scope_variable[file][variable]:
                                                        self.__file_scope_variable[file][variable].append(item)
                                elif self.__variable.has_key(variable):
                                        self.__file_scope_variable[file][variable] = self.__variable[variable] + value.split()
                                else:
                                        self.__file_scope_variable[file][variable] = value.split()
                        else:
                                if self.__variable.has_key(variable):
                                        for item in value.split():
                                                if not item in self.__variable[variable]:
                                                        self.__variable[variable].append(item)
                                else:
                                        self.__variable[variable] = value.split()
                                for file in self.__file_scope_variable.keys():
                                        if not self.__file_scope_variable[file].has_key(variable):
                                                for item in value.split():
                                                        if not item in self.__file_scope_variable[file][variable]:
                                                                self.__file_scope_variable[file][variable].append(item)
                elif operator == '-=':
                        if filename:
                                file = File(filename)
                                if self.__file_scope_variable.has_key(file):
                                        if self.__file_scope_variable[file].has_key(variable):
                                                for item in value.split():
                                                        if item in self.__file_scope_variable[file][variable]:
                                                                self.__file_scope_variable[file][variable].remove(item)
                        else:
                                if self.__variable.has_key(variable):
                                        for item in value.split():
                                                if item in self.__variable[variable]:
                                                        self.__variable[variable].remove(item)
                                for file in self.__file_scope_variable.keys():
                                        if self.__file_scope_variable[file].has_key(variable):
                                                for item in value.split():
                                                        if item in self.__file_scope_variable[file][variable]:
                                                                self.__file_scope_variable[file][variable].remove(item)
                else:
                        warning('unknown operator "' + operator + '"', profilename, proline)
                        sys.exit(1)

        # Modification de la valeur d'une variable du projet. La variable n'est
        # modifi� que si les qualificatifs correspondent �la plateforme et aux
        # options courantes. Suivant le type d'op�ateur appliqu� la valeur de
        # la variable peut �re augment� ou diminu�.
        def insert(self, filename, scopes, variable, operator, value, profilename, proline):
                if variable == 'TEMPLATE':
                        if filename:
                                warning('filename scope cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if scopes:
                                warning('scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if operator != '=':
                                warning('operator "' + operator + '" cannot be used on variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if self.__variable.has_key(variable):
                                warning('"' + variable + '" has already been set', profilename, proline)
                                # (denis) je desactive ca, dans les config automatiques, on a parfois 2 fois ces variables
                                #sys.exit(1)
                        if value == 'lib':
                                self.__variable[variable] = self.lib
                        elif value == 'app':
                                self.__variable[variable] = self.app
                        elif value == 'subdirs':
                                self.__variable[variable] = self.sub
                        elif value == 'package':
                                self.__variable[variable] = self.pak
                        elif value == 'bundle':
                                if platform.systemname() == 'darwin':
                                        self.__variable[variable] = self.bdl
                                else:
                                        self.__variable[variable] = self.lib
                        elif value == 'sip':
                                self.__variable[variable] = self.sip
                        elif value == 'swig':
                                self.__variable[variable] = self.swig
                        else:
                                warning('illegal value "' + value + '" for variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                elif variable == 'CONFIG':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                # (denis) je desactive ca, dans les config automatiques, on a parfois 2 fois ces variables
                                #sys.exit(1)
                        if scopes:
                                warning('scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if operator != '=':
                                warning('operator "' + operator + '" cannot be used on variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if self.__variable.has_key(variable):
                                warning('"' + variable + '" has already been set', profilename, proline)
                                # (denis) je desactive ca, dans les config automatiques, on a parfois 2 fois ces variables
                                #sys.exit(1)
                        self.__variable[variable] = value
                        for option in string.split(value):
                                if option == 'mpi':
                                        self.__compiler = Compiler.mpi
                                elif option == 'native':
                                        self.__compiler = Compiler.native
                                elif option == 'gcc':
                                        self.__compiler = Compiler.gnu
                                elif option == 'debug':
                                        self.__mode = self.debug
                                elif option == 'release':
                                        self.__mode = self.release
                                elif option == 'warn_on':
                                        self.__warn = TRUE
                                elif option == 'warn_off':
                                        self.__warn = FALSE
                                elif option == 'thread':
                                        self.__thread = TRUE
                                elif option == 'qt':
                                        pass
                                else:
                                        warning('skipping unknown value "' + value + '" for variable "' + variable + '"', profilename, proline)
                elif variable == 'TARGET':
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if operator != '=':
                                warning('operator "' + operator + '" cannot be used on variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if self.__variable.has_key(variable):
                                # (denis) je desactive ca, dans les config automatiques, on a parfois 2 fois ces variables
                                warning('"' + variable + '" has already been set (' + self.__variable[variable] + ')', profilename, proline)
                                #sys.exit(1)
                        self.__variable[variable] = value
                elif variable == 'VERSION':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if scopes:
                                warning('scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        if operator != '=':
                                warning('operator "' + operator + '" cannot be used on variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        #if self.__variable.has_key(variable):
                                # (denis) je desactive ca, dans les config automatiques, on a parfois 2 fois ces variables
                                #warning('"' + variable + '" has already been set', profilename, proline)
                                #sys.exit(1)
                        if value == '':
                          self.__variable[variable] = []
                        else:
                          self.__variable[variable] = string.split(value, '.')
                elif variable == 'HEADERS' or variable == 'HEADERS_STATIC':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.file_insert(variable, operator, value, profilename, proline)
                elif variable == 'SOURCES' or variable == 'GENERICS' or variable == 'SIPS' or variable == 'SOURCES_ICE_TO_CPP':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.file_insert(variable, operator, value, profilename, proline)
                elif variable == 'SUBDIRS':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.file_insert(variable, operator, value, profilename, proline)
                elif variable == 'PSUBDIRS':
                        if filename:
                                warning('filename scopes cannot be applied to variable "' + variable + '"', profilename, proline)
                                sys.exit(1)
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.file_insert(variable, operator, value, profilename, proline)
                elif variable == 'DEFINES':
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.qualified_insert(filename, variable, operator, value, profilename, proline)
                elif variable == 'INCLUDEPATH':
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.qualified_insert(filename, variable, operator, value, profilename, proline)
                elif variable == 'LIBS':
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        self.qualified_insert(filename, variable, operator, value, profilename, proline)
                else:
                        for s in scopes:
                                if not self.active_scope(s, variable, platform, profilename, proline):
                                        return
                        defmodule = re.compile(r'\s*defmodule\s*\(\s*([^\s\)]*)\s*\)\s*$')
                        dmodmatch = defmodule.match( variable )
                        if dmodmatch:
                                modname = dmodmatch.group(1)
                                if modname:
                                        if value and value != '0' and value != 'OFF' and value != 'off':
                                                if modname not in self.__modules:
                                                        self.__modules.append( modname )
                                        else:
                                                if modname in self.__modules:
                                                        self.__modules.remove( modname )
                        else:
                                self.qualified_insert(filename, variable, operator, value, profilename, proline)

        def filename(self):
                return self.__filename

        def template(self):
                return self.__variable.get('TEMPLATE', None)

        def target(self):
                return self.__variable.get('TARGET', None)

        def binbdir(self):
                return self.__binbdir

        def incbdir(self):
                return self.__incbdir

        def binfile(self):
                return self.__binfile

        def incfile(self):
                return self.__incfile

        def libfile(self):
                return self.__libfile

        def pyfile(self):
                return self.__pyfile

        def libbdir(self):
                return self.__libbdir

        def version(self):
                return self.__variable.get('VERSION', ())

        def compiler(self):
                return self.__compiler

        def mode(self):
                return self.__mode

        def warn(self):
                return self.__warn

        def thread(self):
                return self.__thread

        def cplusplus(self):
                return self.__cpp

        def variable(self, key):
                return self.__variable.get(key)

        def variables( self ):
                return self.__variable.keys()

        def hasVariable(self, key):
                return self.__variable.has_key(key)

        def setVariable(self, key, value):
                self.__variable[key] = value

        def expandMakefileVariables( self, makefileValue ):
#          sys.stdout.write( '!expandMakefileVariables! ' + repr( makefileValue ) )
          while True:
            match = re.search( '\$[\(\{]([^\)\}]+)[\)\}]', makefileValue )
            if not match: break
            if self.hasVariable( match.group(1) ):
              var = self.variable( match.group(1) )
              if type( var ) is types.ListType \
                      or type( var ) is types.TupleType:
                var = string.join( var )
            else:
              print '!no variable!', match.group( 1 )
              var = os.environ.get( match.group(1), '' )
            makefileValue = makefileValue[:match.start(0)] + var + makefileValue[match.end(0):]
 #         print ' =', repr( makefileValue )
          return makefileValue


# -----------------------------------------------------------------------------
#
# project file
#
#         Cette classe lit un fichier de projet *.pro ligne par ligne. La m�hode
#         'read' analyse syntaxiquement chaque ligne, la d�oupe et l'ins�e dans
#         l'instance de Project 'project' de Project fournie en argument.
#         Toutefois :
#         - Les lignes vides ou contenant uniquement un commentaire sont
#           totalement ignor�s.
#         - Les lignes finissant par un caract�e '\' sont coll�s �la ligne
#           suivante.
#
# -----------------------------------------------------------------------------

class ProjectFile:

        __recursion = 0

        def __init__(self, filename, dirname=None, builddir=None, silent=0 ):
                if dirname:
                        self._name = os.path.normpath(os.path.join(dirname, filename))
                        self._base = dirname
                else:
                        self._name = os.path.normpath(filename)
                        self._base = os.getcwd()
                if builddir:
                        if dirname:
                                self._builddir = \
                                               os.path.normpath( os.path.join( builddir,
                                                                               os.path.dirname( filename ) ) )
                        else:
                                self._builddir = builddir
                else:
                        self._builddir = os.path.dirname(os.path.normpath(os.path.join(self._base, self._name)))
                self._file = None
                self._line = 0
                self._silent = silent

        class Line:

                def __init__(self, data, filename, line):
                        self.scope, self.source, self.variable, self.operator, self.value = data
                        self.filename = filename
                        self.number = line

        def read(self, project):
                # ouvrir le fichier de projet
                try:
                        self._file = open(self._name, 'r')
                except IOError, (errno, strerror):
                        if not self._silent and self._name[-6:] != '-local':
                                warning(strerror, self._name)
                        return 1
                unwrapped = ''
                self.__recursion = self.__recursion + 1
                modules = []
                # lire les lignes du fichier de projet une par une
                inline = self._file.readline()
                while inline:
                        self._line = self._line + 1
                        skip = FALSE
                        # compatibilite avec le systeme #!include de maker 1.0
                        include = re.compile(r'\s*#!\s*include\s+(.*)')
                        match = include.match(inline)
                        if match:
                                filename = match.group(1)
                                dirname = self._builddir
                                #print 'include1', filename, dirname, self._builddir
                                include = ProjectFile(filename, dirname,
                                                      self._builddir, 1)
                                if include.read(project):
                                  dirname = os.path.dirname( os.path.normpath( self._name ) )
                                  #print 'include2', filename, dirname, self._builddir, self._base, self._name
                                  include = ProjectFile(filename, dirname,
                                                        self._builddir)
                                  include.read(project)
                                skip = TRUE
                        # supprimer les commentaires
                        i = inline.find('#')
                        if i >= 0:
                                inline = inline[:i]
                                inline.rstrip()
                                if not inline:
                                        skip = TRUE
                        # ne pas du tout tenir compte de certaines lignes
                        if not skip:
                                # deplier les lignes pliees
                                wrapper = re.compile(r'((.*[^\\])?)\\+\s*$')
                                match = wrapper.match(inline)
                                if match:
                                        # la ligne courante est pliee, memoriser et passer a la suite
                                        inline = match.group(1)
                                        if unwrapped:
                                                unwrapped = unwrapped + ' ' + inline.strip()
                                        else:
                                                unwrapped = inline.strip()
                                else:
                                        # la ligne est depliee, la traiter
                                        if unwrapped:
                                                unwrapped = unwrapped + ' ' + inline.strip()
                                        else:
                                                unwrapped = inline.strip()
                                        # sauter les lignes vides
                                        if unwrapped:
                                                if unwrapped.isspace():
                                                        continue
                                                # decouper la ligne en deux morceaux autour de '=', '+=', '-=', etc.
                                                index = unwrapped.find('=')
                                                if index > 0:
                                                        if unwrapped[index-1:index] == '+':
                                                                operator = '+='
                                                                key = unwrapped[:index-1]
                                                        elif unwrapped[index-1:index] == '*':
                                                                operator = '*='
                                                                key = unwrapped[:index-1]
                                                        elif unwrapped[index-1:index] == '-':
                                                                operator = '-='
                                                                key = unwrapped[:index-1]
                                                        else:
                                                                operator = '='
                                                                key = unwrapped[:index]
                                                        key = string.rstrip(key)
                                                        value = string.lstrip(unwrapped[index+1:])
                                                        # parser le groupe avant '=', '+=', '-=', etc.
                                                        index = key.rfind(':')
                                                        if index < 0:
                                                                variable = key.strip()
                                                                filename = None
                                                                scope = ()
                                                        else:
                                                                scope = key[:index]
                                                                index = index + 1
                                                                variable = key[index:]
                                                                variable = variable.strip()
                                                                index = scope.rfind(':')
                                                                if index < 0:
                                                                        filename = None
                                                                else:
                                                                        filename = key[:index]
                                                                        index = index + 1
                                                                        scope = key[index:]
                                                                scope = scope.split('-')
                                                        # ajouter au projet
                                                        project.insert(filename, scope, variable, operator, value, self._name, self._line)
                                                else:
                                                        warning('line needs an operator such as \'=\'', self._name, self._line)
                                                        sys.exit(1)
                                                unwrapped = ''
                        inline = self._file.readline()
                # on devrait avoir epuise unwrapped, sinon c'est une erreur
                if unwrapped:
                        warning('missing end-of-line at end-of-file', self._name, self._line)
                        sys.exit(1)
                self.__recursion = self.__recursion - 1
                # fermer le fichier de projet
                try:
                        self._file.close()
                        self._file = None
                        self._line = 0
                except IOError, (errno, strerror):
                        warning(strerror, self._name)


# -----------------------------------------------------------------------------
#
# command line parser
#
#         Cette classe interpr�e les arguments de la ligne de commande de ce
#         programme. Ces arguments sont fournis �la m�hode 'parse' qui effectue
#         le travail d'interpr�ation et m�orise les options ainsi demand�s.
#
# -----------------------------------------------------------------------------

import cPickle
import getopt

class Options:

  optimize = 0x0100
  debug    = 0x0200

  vendor = 0x0010
  gcc    = 0x0020
  mpi    = 0x0040

  def __init__(self):
    self.__name = None
    self.__mode = None
    self.__system = None
    self.__compiler = None
    self.__output = None
    self.__vpath = None
    self.__binbdir = None
    self.__incbdir = None
    self.__libbdir = None
    self.__targetkludge = None
    self.__binfile = None
    self.__incfile = None
    self.__libfile = None
    self.__pyfile = None
    self.__buildmode = None

  def usage(self, stream):
    stream.write('Usage: ' + os.path.basename(sys.argv[0]) + ' [options] file\n')
    stream.write('Options:\n')
    stream.write('  -d, --debug           build a debug target\n')
    stream.write('  -r, --release         build a release target\n')
    stream.write('  -n, --native          use the native compiler\n')
    stream.write('  --buildMode           free build mode name\n')
    stream.write('  -g, --gcc             use the GNU compiler\n')
    stream.write('  -m, --mpi             use the MPI compiler\n')
    stream.write('  -c, --compiler=<name> use the specified compiler\n')
    stream.write('  -s, --system=<name>   generate a Makefile for this operating system\n')
    stream.write('  -p, --path=<vpath>    set VPATH to <vpath> in resulting Makefiles\n')
    stream.write('      --binbdir=<dir>   specify a target directory for user executables\n')
    stream.write('      --incbdir=<dir>   specify a directory for header files\n')
    stream.write('      --libbdir=<dir>   specify a target directory for object code libraries\n')
    stream.write('      --binfile=<file>  specify an output file to append executables list\n')
    stream.write('      --incfile=<file>  specify an output file to append libraries headers list\n')
    stream.write('      --libfile=<file>  specify an output file to append libraries list\n')
    stream.write('      --pyfile=<file>   specify an output file to append python files/modules list\n')
    stream.write('  -o <file>             place the output into <file>\n')
    stream.write('  -t, --target          only output the name of the target and exit\n')
    stream.write('  -v, --version         print version, then exit\n')
    stream.write('  -h, --help            print this help, then exit\n')
    stream.write('\n')
    stream.write('Report bugs at http://brainvisa.info/forum/\n')

################################################################################
#  def readCache(self):
#    dirname = os.getcwd()
#    while 1:
#      filename = dirname + '/.maker'
#      if os.path.exists(filename):
#        x = cPickle.load(filename)
#        mode = x.get('mode')
#        if mode == 'debug':
#          self._mode = self.debug
#        if mode == 'optimize':
#          self._mode = self.optimize
#        compiler = x.get('compiler')
#        if compiler == 'vendor':
#          self._compiler = Compiler.vendor
#        if compiler == 'gnu':
#          self._compiler = Compiler.gnu
#        if compiler == 'mpi':
#          self._compiler = Compiler.mpi
#        vpath = x.get('vpath')
#        if vpath:
#          self._vpath = vpath
#        break
#      if dirname == os.path.dirname(dirname):
#        break
#      dirname = os.path.dirname(dirname)
#
#  def writeCache(self):
#    x = {}
#    if self._mode == self.debug:
#      x['mode'] = 'debug'
#    elif self._mode == self.optimize:
#      x['mode'] = 'optimize'
#    if self._compiler == Compiler.vendor:
#      x['compiler'] = 'vendor'
#    elif self._compiler == Compiler.gnu:
#      x['compiler'] = 'gnu'
#    elif self._compiler == Compiler.mpi:
#      x['compiler'] = 'mpi'
#    if self._vpath:
#      x['vpath'] = self._vpath
#    filename = os.getcwd() + '/.maker'
#    cPickle.dump(x, filename)
################################################################################

  def parse(self, argv, platform):
    # keep track of how we were invoked
    self.argv = copy.copy( argv )
    s = 'rdingmc:s:p:o:tvh'
    l = ['release', 'debug', 'native', 'gcc', 'mpi', 'compiler=', 'system=',
         'path=', 'binbdir=', 'incbdir=', 'libbdir=', 'target', 'version',
         'help', 'binfile=', 'incfile=', 'libfile=', 'pyfile=', 'buildMode=' ]
    try:
      optlist, args = getopt.getopt(argv[1:], s, l)
    except getopt.error, msg:
      warning(str(msg) + '\nTry \'maker -h\' for more information.')
      sys.exit(2)
    self.__system = platform.system()
    for option, argument in optlist:
      if option == '-r' or option == '--release':
        self.__mode = self.optimize
        if self.__buildmode is None:
          self.__buildmode = 'release'
      elif option == '-d' or option == '--debug':
        self.__mode = self.debug
        if self.__buildmode is None:
          self.__buildmode = 'debug'
      elif option == '-n' or option == '--native':
        self.__compiler = OS.compiler(platform.system())
      elif option == '-g' or option == '--gcc':
        self.__compiler = Compiler.gnu
      elif option == '-m' or option == '--mpi':
        self.__compiler = Compiler.mpi
      elif option == '-c' or option == '--compiler':
        compiler = argument.lower()
        if compiler == 'vendor' or compiler == 'native':
          s = platform.system()
          c = OS.compiler(self.__system)
          if c:
            self.__compiler = c
          else:
            warning('System "' + OS.name(self.__system) + '" does not have a native compiler.')
            sys.exit(2)
        elif compiler == 'mpi':
          self.__compiler = Compiler.mpi
        elif compiler == 'gnu' or compiler == 'gcc':
          self.__compiler = Compiler.gnu
        elif compiler == 'intel' or compiler == 'icc':
          self.__compiler = Compiler.intel
        elif compiler == 'sun' or compiler == 'workshop' or compiler == 'forte':
          self.__compiler = Compiler.sun
        elif compiler == 'mips' or compiler == 'mipspro' or compiler == 'sgi':
          self.__compiler = Compiler.mips
        elif compiler == 'compaq' or compiler == 'cxx':
          self.__compiler = Compiler.compaq
        elif compiler == 'msvc' or compiler == 'microsoft':
          self.__compiler = Compiler.msvc
        elif compiler == 'borland' or compiler == 'bcc':
          self.__compiler = Compiler.borland
        else:
          warning('"' + argument + '" is not a known compiler name.')
          sys.exit(2)
      elif option == '-s' or option == '--system':
        system = argument.lower()
        if system == 'linux':
          self.__system = OS.linux
        elif system == 'solaris' or system == 'sun' or system == 'sunos':
          self.__system = OS.solaris
        elif system == 'irix' or system == 'sgi':
          self.__system = OS.irix
        elif system == 'tru64' or system == 'digital':
          self.__system = OS.tru64
        elif system == 'win32' or system == 'windows':
          self.__system = OS.win32
        elif system == 'darwin':
          self.__system = OS.darwin
        elif system == 'cygwin':
          self.__system = OS.cygwin
        else:
          warning('"' + argument + '" is not a known operating system name.')
          sys.exit(2)
      elif option == '-p' or option == '--path':
        self.__vpath = argument
      elif option == '--binbdir':
        self.__binbdir = argument
      elif option == '--incbdir':
        self.__incbdir = argument
      elif option == '--libbdir':
        self.__libbdir = argument
      elif option == '-o':
        self.__output = argument
      elif option == '-t' or option == '--target':
        self.__targetkludge = 1
      elif option == '-v' or option == '--version':
        sys.stdout.write('Maker ' + version \
                         + '\nCopyright (c) 2000-2006 CEA/SHFJ\n')
        sys.exit(0)
      elif option == '-h' or option == '--help':
        self.usage(sys.stdout)
        sys.exit(0)
      elif option == '--binfile':
        self.__binfile = argument
      elif option == '--incfile':
        self.__incfile = argument
      elif option == '--libfile':
        self.__libfile = argument
      elif option == '--pyfile':
        self.__pyfile = argument
      elif option == '--buildMode':
        self.__buildmode = argument
    if len(args) < 1:
      warning('Insufficient arguments (' + str(len(args)) + ')')
      sys.exit(2)
    if len(args) > 1:
      warning('Too many arguments (' + str(len(args)) + ')')
      sys.exit(1)
    self.__project = args[0]
    if self.__buildmode is None:
      self.__buildmode = 'default'

  def project(self):
    return self.__project

  def vpath(self):
    return self.__vpath

  def binbdir(self):
    return self.__binbdir

  def incbdir(self):
    return self.__incbdir

  def libbdir(self):
    return self.__libbdir

  def binfile(self):
    return self.__binfile

  def incfile(self):
    return self.__incfile

  def libfile(self):
    return self.__libfile

  def pyfile(self):
    return self.__pyfile

  def mode(self):
    return self.__mode

  def buildMode( self ):
    return self.__buildmode

  def system(self):
    return self.__system

  def compiler(self):
    return self.__compiler

  def output(self):
    return self.__output

  def targetkludge(self):
    return self.__targetkludge


# -----------------------------------------------------------------------------
#
# Unix Makefile
#
#         Cette classe transforme un projet en makefile pour UNIX. Les r�les
#         sont explicites pour pouvoir modifier les options de compilation
#         fichier par fichier. Les r�les �ant explicites, l'utilisation de
#         VPATH est inutile.
#
# -----------------------------------------------------------------------------

import time


class UnixMakefile:

  def makefileString( self, text ):
    pat = re2.compile( r'\\([^ \n\t])', re2.MULTILINE )
    return re2.sub( pat, r'\\\\\1', text )
    #return re.sub( pat, r'roro\1', text )

  def write(self, project, platform, stream=sys.stdout):
    stream.write('########################################\n')
    stream.write('#      Project: ' + project.filename() + '\n')
    stream.write('#     Template: ')
    if project.template() == Project.lib:
      stream.write('lib')
    if project.template() == Project.app:
      stream.write('app')
    if project.template() == Project.sub:
      stream.write('subdirs')
    if project.template() == Project.pak:
      stream.write('package')
    if project.template() == Project.bdl:
      stream.write('bundle')
    if project.template() == Project.sip:
      stream.write('sip')
    if project.template() == Project.swig:
      stream.write('swig')
    stream.write('\n')
    localtime = time.localtime(time.time())
    stream.write('# Generated on: ' + time.asctime(localtime) + '\n')
    stream.write('# Generated by: Maker ' + version + '\n')
    stream.write('########################################\n')

    stream.write('\n\n')
    stream.write('#---------------------------------------\n')
    stream.write('# Compiler, tools and options\n')
    stream.write('#---------------------------------------\n')

    if project.template() == Project.lib \
           or project.template() == Project.app \
           or project.template() == Project.bdl \
           or project.template() == Project.swig \
           or project.template() == Project.sip:
      #vars = ( 'CC', 'CXX', 'CFLAGS_WARN_ON', 'CFLAGS',
      #         'CXXFLAGS', 'CXXFLAGS_WARN_ON',
      #         'CFLAGS_WARN_OFF', 'CXXFLAGS_WARN_OFF',
      #         'CFLAGS_THREAD', 'CXXFLAGS_THREAD',
      #         'LFLAGS_THREAD', 'CFLAGS_SHLIB',
      #         'CXXFLAGS_SHLIB', 'LFLAGS', 'LFLAGS_SHLIB',
      #         'LFLAGS_SONAME', 'LINKCC', 'LINKCXX',
      #         'LINKCC_SHARED', 'LINKCXX_SHARED', 'EXTENSION_SHLIB' )
      vars = project.variables()
      stream.write('\n')
      for var in vars:
        # write all non-special variables as is
        if var not in ( 'SOURCES', 'HEADERS',
                        'HEADERS_STATIC', 'DEFINES', 
                        'GENERICS', 'PREPROCESSOR',
                        'SUBDIRS', 'PSUBDIRS',
                        'TARGET', 'TEMPLATE',
                        'INCLUDEPATH', 'LIBS',
                        'SIPS', 'SOURCES_ICE_TO_CPP' ):
          stream.write(var + ' = ')
          #if project.variable( var ):
          val = project.variable(var)
          if type( val ) in ( types.ListType, types.TupleType ):
            stream.write( unixpath( string.join(val) ) )
          else:
            stream.write( unixpath( str( val ) ) )
          stream.write('\n')

    stream.write('\n')
    stream.write('MOC  = ' + self.makefileString( os.path.join( '$(QTDIR)', 'bin', 'moc' ) ) + '\n')
    stream.write('UIC  = ' + self.makefileString( os.path.join( '$(QTDIR)', 'bin', 'uic' ) ) + '\n')
    stream.write('RM   = rm -f\n')
    stream.write('TAR  = tar -cf\n')
    stream.write('GZIP = gzip -9f\n')
    stream.write('LN   = ln -s\n')
    if project.hasVariable( 'PREPROCESSOR' ):
      stream.write( 'PREPROC = ' \
                    + self.makefileString(
        os.path.join( project.binbdir(),
                      project.variable( 'PREPROCESSOR' )[0] ) ) )
    if project.hasVariable( 'SOURCES_ICE_TO_CPP' ):
      stream.write( 'SLICE2CPP = slice2cpp --source-ext cxx' )

    stream.write('\n\n')
    stream.write('#---------------------------------------\n')
    stream.write('# Files\n')
    stream.write('#---------------------------------------\n')

    if project.template() == Project.pak:
      stream.write('\n')
    elif project.template() == Project.sub:
      stream.write('\nSUBDIRS =')
      if project.hasVariable('SUBDIRS'):
        for d in project.variable('SUBDIRS'):
          stream.write('\\\n\t' + self.makefileString( d.name() ) )
        stream.write('\n')
      stream.write('\nPSUBDIRS =')
      if project.hasVariable('PSUBDIRS'):
        for d in project.variable('PSUBDIRS'):
          stream.write('\\\n\t' + self.makefileString( d.name() ) )
      stream.write('\n')
    elif project.template() == Project.lib \
             or project.template() == Project.app \
             or project.template() == Project.bdl \
             or project.template() == Project.swig \
             or project.template() == Project.sip:
      stream.write('\n')
      if project.template() != Project.sip:
        if project.hasVariable( 'GENERICS' ):
          stream.write( 'GENERICS = ' )
          for gen in project.variable( 'GENERICS' ):
            stream.write( '\\\n\t' + unixpath( os.path.join( gen.dirname(), gen.basename() ) + '_gen.c  ' ) )
          stream.write( '\n' )
        if project.hasVariable( 'SOURCES_ICE_TO_CPP' ):
          stream.write( 'SOURCES_ICE_TO_CPP = ' )
          for ice in project.variable( 'SOURCES_ICE_TO_CPP' ):
            stream.write( '\\\n\t' + unixpath( os.path.join( ice.dirname(), ice.basename() ) + '.cxx  ' ) )
          stream.write( '\n\n' )
          stream.write( 'SYMLINKS_SOURCES_ICE = ' )
          for ice in project.variable( 'SOURCES_ICE_TO_CPP' ):
                  stream.write( '\\\n\t' + unixpath( os.path.join( ice.dirname(), ice.basename() ) + '.ice  ' ) )

          stream.write( '\n' )
        stream.write( '\n' )
      stream.write('HEADERS = ')
      if project.hasVariable('HEADERS'):
        for header in project.variable('HEADERS'):
          stream.write('\\\n\t' + unixpath( header.fullname() ) + '  ')
      if project.hasVariable('HEADERS_STATIC'):
        for header in project.variable('HEADERS_STATIC'):
          stream.write('\\\n\t' + unixpath( header.fullname() ) + '  ')
      stream.write('\n')
      if project.incbdir():
        stream.write('\n')
        stream.write('SYMLINKS =')
        if project.hasVariable('HEADERS'):
          incfile = project.incfile()
          if incfile:
            f = open( incfile, 'a' )
          for header in project.variable('HEADERS'):
            x = os.path.normpath( os.path.join(project.incbdir(),
                                               header.fullname()) )
            x = project.expandMakefileVariables( x )
            x = unixpath( x )
            stream.write('\\\n\t' + x + '  ')
            if incfile and project.template() in ( Project.lib, Project.bdl ):
              f.write(x + '\n')
          if incfile:
            f.close()
        if project.hasVariable('HEADERS_STATIC'):
          if project.hasVariable( 'INCLUDE_STATIC' ):
            ipth = project.variable( 'INCLUDE_STATIC' )[0]
          else:
            ipth = project.incbdir()
          for header in project.variable('HEADERS_STATIC'):
            stream.write('\\\n\t' + unixpath(  os.path.normpath(
              os.path.join(ipth, header.fullname()) ) ) + '  ')
        stream.write('\n')
      stream.write('\n')
      if project.template() != Project.sip:
        stream.write('SOURCES =')
        if project.hasVariable('SOURCES'):
          for source in project.variable('SOURCES'):
            stream.write('\\\n\t' + unixpath( source.fullname() ) )
        stream.write('\n')
        stream.write('\n')
        stream.write('SRCMOC =')
        if project.hasVariable('HEADERS'):
          for header in project.variable('HEADERS'):
            if File(project.vppath(header.fullname())).moc():
              stream.write('\\\n\t' + unixpath(  os.path.normpath(
                os.path.join(header.dirname(), 'moc_' + header.basename() \
                             + header.suffix()) ) ) )
        stream.write('\n')
        stream.write('\n')
        stream.write('OBJECTS =')
        if project.hasVariable('SOURCES'):
          for source in project.variable('SOURCES'):
            stream.write('\\\n\t' + unixpath( os.path.join(source.dirname(), source.basename() + '.o') ) )
        if project.hasVariable('GENERICS'):
          for source in project.variable('GENERICS'):
            stream.write('\\\n\t' + unixpath( os.path.join(source.dirname(), source.basename() + '_gen.o') ) )
        if project.hasVariable('SOURCES_ICE_TO_CPP'):
          for source in project.variable('SOURCES_ICE_TO_CPP'):
            stream.write('\\\n\t' + unixpath( os.path.join(source.dirname(), source.basename() + '.o') ) )
        stream.write('\n')
        stream.write('\n')
        stream.write('OBJMOC =')
        if project.hasVariable('HEADERS'):
          for header in project.variable('HEADERS'):
            if File(project.vppath(header.fullname())).moc():
              stream.write('\\\n\t' + unixpath(  os.path.normpath(
                os.path.join(header.dirname(), 'moc_' + header.basename() \
                             + '.o') ) ) )
        stream.write('\n')
        stream.write('\n')
        stream.write('DEPEND =')
        if project.template() == Project.swig:
          swigfile = project.variable('SWIG_FILE')
          if len(swigfile) != 1:
            warning('SWIG_FILE should have only one value, taking last')
          swigfile = swigfile[0]
          swig_d = swigfile[:-2] + '_wrap.d'
          stream.write(' ' + swig_d + '\n\n')
        elif project.hasVariable('SOURCES'):
          for source in project.variable('SOURCES'):
            stream.write('\\\n\t' + unixpath( os.path.join(source.dirname(), source.basename() + '.d') ) )
        if project.hasVariable('HEADERS'):
          for header in project.variable('HEADERS'):
            if File(project.vppath(header.fullname())).moc():
              stream.write('\\\n\t' + unixpath(  os.path.normpath(
                os.path.join(header.dirname(), 'moc_' + header.basename() \
                             + '.d') ) ) )
        stream.write('\n')
        stream.write('\n')
      stream.write('DEFINES =')
      if project.hasVariable('DEFINES'):
        for define in project.variable('DEFINES'):
          stream.write(' -D' + define)
      stream.write('\n')
      stream.write('\n')
      stream.write('INCPATH =')
      if project.hasVariable('INCLUDEPATH'):
        for incpath in project.variable('INCLUDEPATH'):
          stream.write(' -I' + self.makefileString( incpath ) )
      stream.write('\n')
      stream.write('\n')
      stream.write('LIBS = ')
      if project.hasVariable('LIBS'):
        stream.write(self.makefileString( string.join(project.variable('LIBS'))) )
      stream.write('\n')
      stream.write('\n')
      if project.template() == Project.sip:
        if project.hasVariable( 'SIPS' ):
          if project.libbdir():
            pydir = project.libbdir()
          elif project.hasVariable('DESTDIR'):
            pydir = project.variable('DESTDIR')
          if pydir:
            pydir = os.path.normpath( os.path.join( pydir, '..', 'python' ) )
          else:
            pydir = '.'
          pysrc = os.path.join( project.vpath(), 'src', 'python' )
          pythons = []
          if os.path.isdir( pysrc ):
            pythons = os.listdir( pysrc )
            if len( pythons ) != 0:
              stream.write( 'PYTHONS = ' )
              for source in pythons:
                stream.write( '\\\n\t' + unixpath( os.path.join( pydir, source ) ) )
          stream.write( '\n' )
      #    stream.write( 'SIPS = ' )
      #    for source in project.variable( 'SIPS' ):
      #      stream.write( '\\\n\t' + unixpath( os.path.join( pydir, source.basename() + '.py' ) ) )
      #    stream.write( '\n' )

    stream.write('\n\n')
    stream.write('#---------------------------------------\n')
    stream.write('# Targets\n')
    stream.write('#---------------------------------------\n')

    stream.write('\n')
    if project.template() == Project.pak:
      if project.vpath():
        stream.write('VPATH=' + self.makefileString( project.vpath() ) + '\n')
      stream.write('all:\n')
      stream.write('\tcd src ; $(MAKE)\n')
    elif project.template() == Project.sub:
      stream.write('all: subdirs psubdirs\n')
      if project.hasVariable('SUBDIRS'):
        stream.write('\nsubdirs:')
        for d in project.variable('SUBDIRS'):
          stream.write(' sub_' + self.makefileString( d.name() ))
        stream.write('\n')
        lastd = None
        for d in project.variable('SUBDIRS'):
          stream.write('\nsub_' + self.makefileString( d.name() ) + ':')
          if lastd is not None:
            stream.write(' sub_' + self.makefileString( lastd.name() ))
          stream.write('\n\t@if [ -d ' + d.name() + ' ] ; then cd ' \
                       + d.name() + ' ; $(MAKE) ; fi\n')
          lastd = d
      else:
        stream.write('\nsubdirs:\n')
      if project.hasVariable('PSUBDIRS'):
        stream.write('\npsubdirs: subdirs')
        for d in project.variable('PSUBDIRS'):
          stream.write(' sub_' + self.makefileString( d.name() ) )
        stream.write('\n')
        for d in project.variable('PSUBDIRS'):
          stream.write('\nsub_' + self.makefileString( d.name() ) \
                       + ': subdirs')
          stream.write('\n\t@if [ -d ' + d.name() + ' ] ; then cd ' \
                       + d.name() + ' ; $(MAKE) ; fi\n')
      else:
        stream.write('\npsubdirs: subdirs\n')
    elif project.template() == Project.lib \
             or project.template() == Project.bdl:
      if project.hasVariable( 'LIBPREFIX' ):
        prefix = project.variable( 'LIBPREFIX' )
        if prefix is None or len( prefix ) == 0:
          prefix = ''
        else:
          prefix = prefix[0]
        target0 = prefix + project.target()
      else:
        target0 = 'lib' + project.target()
      if project.template() == Project.lib:
        target0 = target0 + '$(EXTENSION_SHLIB)'
      elif project.template() == Project.bdl:
        target0 = target0 + '$(EXTENSION_BUNDLE)'
      target = target0
      for number in project.version():
        target = target + '.' + number
      stream.write('TARGET=' + self.makefileString( target ) + '\n')
      stream.write('\n')
      libbdir = None
      incbdir = None
      destdir = ''
      if project.hasVariable('DESTDIR'):
        libbdir = project.variable('DESTDIR')
        if type( libbdir ) is not types.StringType \
          and operator.isSequenceType( libbdir ):
          libbdir = libbdir[0]
      elif project.libbdir():
        libbdir = project.libbdir()
      if libbdir:
        if not project.hasVariable('DESTDIR'):
          stream.write('DESTDIR=' + unixpath( libbdir ) + '\n')
          stream.write('\n')
        destdir = '$(DESTDIR)' + dirSeparator
      # conditional operations: make first only makes the symlinks, then
      # re-runs 'make COMP=comp' to compile
      stream.write('ifeq ($(COMP),comp)\n')
      stream.write('\n')
      stream.write('all: ')
      stream.write(self.makefileString(destdir))
      stream.write(self.makefileString(target) + '\n')
      stream.write('\n')
      libfile = project.libfile()
      if libfile:
        f = open( libfile, 'a' )
        print >> f, self.makefileString( os.path.normpath( \
          project.expandMakefileVariables( libbdir + dirSeparator + target) ) )
        f.close()
      stream.write(self.makefileString(destdir + target) \
                   + ': $(OBJECTS) $(OBJMOC)\n')
      if libbdir:
        stream.write('\t@[ -d $(DESTDIR) ] || mkdir -p $(DESTDIR)\n')
      stream.write('\t')
      if project.cplusplus():
        stream.write('$(LINKCXX_SHARED)')
      else:
        stream.write('$(LINKCC_SHARED)')
      stream.write(' $(LFLAGS) ')
      if project.thread():
        stream.write('$(LFLAGS_THREAD) ')
      if project.template() == Project.bdl:
        stream.write('$(LFLAGS_BUNDLE) ')
      else:
        stream.write('$(LFLAGS_SHLIB) ')
        soname = project.variable('LFLAGS_SONAME')
        if soname and soname[0]:
          stream.write(self.makefileString(soname[0]) + '$(TARGET) ')
      stream.write('-o ' + self.makefileString( destdir + target ) )
      stream.write(' $(OBJECTS) $(OBJMOC) $(LIBS)\n')
      if target != target0:
        stream.write('\t@')
        if libbdir:
          stream.write('cd $(DESTDIR) && ')
        stream.write('$(RM) ' + self.makefileString(target0) + ' ; \\\n')
        stream.write('\t$(LN) ' + self.makefileString( target ) + ' ' \
                     + self.makefileString( target0 ) + '\n')
      stream.write('\n')

      # end of COMP conditional
      stream.write('else\n')
      stream.write('ifeq ($(COMP),dep)\n')

      # dependencies part
      stream.write('all:\t$(DEPEND)\n')

      # end of COMP conditional
      stream.write('else\n')

      # symlink part
      stream.write('\n')
      stream.write('all:\tsymlinks')
      if project.hasVariable( 'GENERICS' ):
        stream.write( ' generics' )
      if project.hasVariable( 'SOURCES_ICE_TO_CPP' ):
        stream.write( ' sources_ice_to_cpp' )
      stream.write( '\n' )
      stream.write('\t@echo $(MAKE) COMP=dep\n')
      stream.write('\t@if $(MAKE) COMP=dep; then a=1; else \\\n')
      stream.write('\t\techo Rebuilding dependencies; \\\n')
      stream.write('\t\t$(RM) $(DEPEND); \\\n')
      stream.write('\t\t$(MAKE) COMP=dep; \\\n')
      stream.write('\tfi\n')
      stream.write('\t$(MAKE) COMP=comp\n')
      stream.write('\n')
      if project.template() == Project.lib \
             or project.template() == Project.bdl:
        stream.write('symlinks:\t$(SYMLINKS)\n')
      else:
        stream.write('symlinks:\n')
      stream.write('generics:\t$(GENERICS)\n')
      stream.write('sources_ice_to_cpp:\t$(SYMLINKS_SOURCES_ICE) $(SOURCES_ICE_TO_CPP)\n')
      stream.write('\n')
      stream.write('endif\n')
      stream.write('endif\n')
    elif project.template() == Project.app:
      target = project.target()
      stream.write('TARGET=' + self.makefileString( target ) + '\n')
      stream.write('\n')
      binbdir = None
      if project.binbdir():
        binbdir = project.binbdir()
      elif project.hasVariable('DESTDIR'):
        binbdir = project.variable('DESTDIR')
      if binbdir:
        stream.write('DESTDIR=' + unixpath(binbdir) + '\n')
        stream.write('\n')
      # conditional operations: make first only makes the symlinks, then
      # re-runs 'make COMP=comp' to compile
      stream.write('ifeq ($(COMP),comp)\n')
      stream.write('\n')
      stream.write('all: ')
      if binbdir:
        stream.write('$(DESTDIR)' + dirSeparator)
      stream.write(self.makefileString(target) + '\n')
      stream.write('\n')
      binfile = project.binfile()
      if binfile:
        f = open( binfile, 'a' )
        if binbdir:
          n = binbdir + dirSeparator + self.makefileString(target)
        else:
          n = self.makefileString(target)
        if platform.system() == OS.win32 and not n.endswith( '.exe' ) \
          and not n.endswith( '.EXE' ):
          n += '.exe'
        print >> f, project.expandMakefileVariables( n )
        f.close()
      if binbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target) + ': $(OBJECTS) $(OBJMOC)\n')
      if binbdir:
        stream.write('\t@[ -d $(DESTDIR) ] || mkdir -p $(DESTDIR)\n')
      stream.write('\t')
      if project.cplusplus():
        stream.write('$(LINKCXX)')
      else:
        stream.write('$(LINKCC)')
      stream.write(' $(LFLAGS) ' )
      if project.thread():
        stream.write(' $(LFLAGS_THREAD) ')
      stream.write( '-o ')
      if binbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target))
      stream.write(' $(OBJECTS) $(OBJMOC) $(LIBS)\n')
      stream.write('\n')

      stream.write('else\n')
      stream.write('ifeq ($(COMP),dep)\n\n')

      # dependencies part
      stream.write('all:\t$(DEPEND)\n')
      stream.write('\n')

      stream.write('else\n')
      # symlink part
      stream.write('\n')
      stream.write('all:\tsymlinks\n')
      stream.write('\t@echo $(MAKE) COMP=dep\n')
      stream.write('\t@if $(MAKE) COMP=dep; then a=1; else \\\n')
      stream.write('\t\techo Rebuilding dependencies; \\\n')
      stream.write('\t\t$(RM) $(DEPEND); \\\n')
      stream.write('\t\t$(MAKE) COMP=dep; \\\n')
      stream.write('\tfi\n')
      stream.write('\t$(MAKE) COMP=comp\n')
      stream.write('\n')
      stream.write('\n')
      if project.template() == Project.lib:
        stream.write('symlinks:\t$(SYMLINKS)\n')
      else:
        stream.write('symlinks:\n')
      stream.write('\n')
      stream.write('endif\n')
      stream.write('endif\n')
    elif project.template() == Project.swig:
      if not project.hasVariable('SWIG_FILE'):
        warning('swig template muste define SWIG_FILE')
        sys.exit(1)
      swigfile = project.variable('SWIG_FILE')
      if len(swigfile) != 1:
        warning('SWIG_FILE should have only one value, taking last')
      swigfile = swigfile[0]
      swig_object = swigfile[:-2] + '_wrap.o'
      swig_src = swigfile[:-2] + '_wrap.cc'
      destdir = '$(DESTDIR)' + dirSeparator
      target0 = project.target()
      if platform.systemname() == OS.name( OS.darwin ):
        target0 += '$(EXTENSION_BUNDLE)'
      elif platform.systemname() == OS.name( OS.win32 ):
          target0 = target0 + '.pyd'
      else:
        target0 = target0 + '$(EXTENSION_SHLIB)'
      target = target0
      destdir = ''
      if project.hasVariable('DESTDIR'):
        libbdir = project.variable('DESTDIR')
        if type( libbdir ) is not types.StringType \
          and operator.isSequenceType( libbdir ):
          libbdir = libbdir[0]
      elif project.libbdir():
        libbdir = project.libbdir()
      if libbdir:
        if not project.hasVariable('DESTDIR'):
          libbdir = os.path.normpath( os.path.join(libbdir, '..', 'python' ) )
          stream.write('DESTDIR = ' + unixpath( libbdir ) + '\n')
          stream.write('\n')
        destdir = '$(DESTDIR)' + dirSeparator
      stream.write('SWIG_OBJECT = ' + swig_object + '\n\n')
      stream.write('SWIG_SRC = ' + swig_src + '\n\n')
      stream.write('ifeq ($(COMP),comp)\n')
      stream.write('all: ')
      stream.write(self.makefileString(destdir + target) + '\n\n')
      stream.write(self.makefileString(destdir + target) + ': ')
      stream.write(swig_object + '\n')
      if libbdir:
        stream.write('\t@[ -d $(DESTDIR) ] || mkdir -p $(DESTDIR)\n')
      stream.write('\t')
      if project.cplusplus():
        stream.write('$(LINKCXX_SHARED)')
      else:
        stream.write('$(LINKCC_SHARED)')
      stream.write(' $(LFLAGS) ')
      if project.thread():
        stream.write('$(LFLAGS_THREAD) ')
      if project.template() == Project.bdl:
        stream.write('$(LFLAGS_BUNDLE) ')
      else:
        stream.write('$(LFLAGS_SHLIB) ')
        soname = project.variable('LFLAGS_SONAME')
        if soname and soname[0]:
          stream.write(self.makefileString(soname[0]) + '$(TARGET) ')
      stream.write('-o ' + self.makefileString( destdir + target ) + ' ')
      stream.write(swig_object + ' $(LIBS)\n')
      stream.write('else\nifeq ($(COMP),dep)\n')
      stream.write('all:\t$(DEPEND)\nelse\n\n')
      stream.write('all:\tsymlinks\n')
      stream.write('\t@echo $(MAKE) COMP=dep\n')
      stream.write('\t@if $(MAKE) COMP=dep; then a=1; else \\\n')
      stream.write('\t\techo Rebuilding dependencies; \\\n')
      stream.write('\t\t$(RM) $(DEPEND); \\\n')
      stream.write('\t\t$(MAKE) COMP=dep; \\\n')
      stream.write('\tfi\n')
      stream.write('\t$(MAKE) COMP=comp\n\n\n')
      stream.write('symlinks:\t$(SYMLINKS)\n')
      stream.write('\n')
      stream.write('endif\n')
      stream.write('endif\n')

      if target != target0:
        stream.write('\t@')
        if libbdir:
          stream.write('cd $(DESTDIR) && ')
        stream.write('$(RM) ' + self.makefileString(target0) + ' ; \\\n')
        stream.write('\t$(LN) ' + self.makefileString( target ) + ' ' \
                     + self.makefileString( target0 ) + '\n')
      stream.write('\n')




    elif project.template() == Project.sip:
      if platform.sipversion()[0] < 4:
        targetbase = project.target() + 'cmodule'
        target0 = 'lib' + targetbase
        if platform.systemname() == OS.name( OS.darwin ):
          target0 += '$(EXTENSION_BUNDLE)'
        else:
          target0 += '$(EXTENSION_SHLIB)'
        target1 = target0
      else:
        targetbase = project.target()
        target0 = targetbase
        if platform.systemname() == OS.name( OS.darwin ):
          target0 += '$(EXTENSION_BUNDLE)'
        elif platform.systemname() == OS.name( OS.win32 ):
            target0 = target0 + '.pyd'
        else:
          target0 = target0 + '$(EXTENSION_SHLIB)'
        target1 = target0
      target = target1
      sbftarget = project.target() + '.sbf' # Sip project output
      stream.write('TARGET=' + self.makefileString( target ) + '\n')
      stream.write('\n')
      libbdir = None
      incbdir = None
      destdir = ''
      if project.libbdir():
        libbdir = os.path.normpath( os.path.join( project.libbdir(), '..', 
                                                  'python' ) )
      elif project.hasVariable('DESTDIR'):
        libbdir = project.variable('DESTDIR')
      if libbdir:
        stream.write('DESTDIR=' + unixpath( libbdir ) + '\n')
        stream.write('\n')
        destdir = '$(DESTDIR)' + dirSeparator
      stream.write('all:\tpythons ')
      if project.hasVariable( 'HEADERS' ):
        stream.write( 'symlinks ' )
      stream.write(self.makefileString(destdir))
      stream.write(self.makefileString(target) + '\n')
      stream.write('\n')
      pyfile = project.pyfile()
      if pyfile:
        f = open( pyfile, 'a' )
        print >> f, project.expandMakefileVariables( self.makefileString( \
          os.path.normpath( os.path.join( libbdir, target ) ) ) )
        f.close()
      stream.write('force:\n\n')
      stream.write(self.makefileString(destdir + target) + ': ' + sbftarget \
                   + ' force\n')
      stream.write('\tcd sip_code; ${MAKE}\n')
      if target0 != target1:
        t1 = self.makefileString( destdir + target1 )
        stream.write('\t${RM} ' + t1 + '\n')
        if destdir:
          stream.write('\tcd $(DESTDIR); ')
        if target1 != target0:
          stream.write('\\\n\t${LN} "' + target0 + '" "' + target1 + '"\n')
        else:
          stream.write('\n')
      # symlink part
      if project.hasVariable( 'HEADERS' ):
        stream.write('\nsymlinks:\t$(SYMLINKS)\n')
      stream.write( 'pythons:\t$(PYTHONS)\n' )

    if project.template() == Project.sub:
      stream.write('\nclean: clean_subdirs clean_psubdirs\n')
      if project.hasVariable('SUBDIRS'):
        stream.write('\nclean_subdirs: clean_psubdirs')
        for d in project.variable('SUBDIRS'):
          stream.write(' clean_' + self.makefileString( d.name() ))
        stream.write('\n')
        for d in project.variable('SUBDIRS'):
          stream.write('\nclean_' + self.makefileString( d.name() ) \
                       + ': clean_psubdirs\n')
          stream.write('\t@if [ -d ' + d.name() + ' ] ; then cd ' + d.name() \
                       + ' ; $(MAKE) ; fi\n')
      else:
        stream.write('\nclean_subdirs: clean_psubdirs\n')
      if project.hasVariable('PSUBDIRS'):
        stream.write('\nclean_psubdirs:')
        for d in project.variable('PSUBDIRS'):
          stream.write(' clean_' + self.makefileString( d.name() ))
        stream.write('\n')
        for d in project.variable('PSUBDIRS'):
          stream.write('\nclean_' + self.makefileString( d.name() ) + ':\n')
          stream.write('\t@if [ -d ' + d.name() + ' ] ; then cd ' + d.name() \
                       + ' ; $(MAKE) clean ; fi\n')
      else:
        stream.write('\nclean_psubdirs:\n')
      return

    stream.write('\nclean:\n')
    if project.template() == Project.pak:
      stream.write('\tcd src ; $(MAKE) clean\n')
    elif project.template() == Project.swig:
      target = project.target() + '$(EXTENSION_SHLIB)'
      swigfile = project.variable('SWIG_FILE')
      if len(swigfile) != 1:
        warning('SWIG_FILE should have only one value, taking last')
      swigfile = swigfile[0]
      swig_object = swigfile[:-2] + '_wrap.o'
      swig_d = swigfile[:-2] + '_wrap.d'
      stream.write('\t-$(RM) $(SWIG_OBJECT) $(SWIG_SRC) $(DEPENDS)')
      stream.write('$(DESTDIR)' + dirSeparator)
      stream.write(self.makefileString(target) + '\n')
    elif project.template() == Project.lib:
      target = target0 = 'python' + project.target() + '$(EXTENSION_SHLIB)'
      for number in project.version():
        target = target + '.' + number
      stream.write('\t-$(RM) $(OBJMOC) $(SRCMOC) $(OBJECTS) $(DEPEND) '
                   '$(SYMLINKS) ')
      if libbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target) + ' ')
      if libbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target0) + '\n')
    elif project.template() == Project.app:
      stream.write('\t-$(RM) $(OBJMOC) $(SRCMOC) $(OBJECTS) $(DEPEND) ')
      if binbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(project.target()) + '\n')
    elif project.template() == Project.sip:
      target = target0 # = 'lib' + project.target() + 'cmodule$(EXTENSION_SHLIB)'
      for number in project.version():
        target = target + '.' + number
      stream.write('\t-$(RM) -r sip_code ')
      if libbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target) + ' ')
      if libbdir:
        stream.write('$(DESTDIR)' + dirSeparator )
      stream.write(self.makefileString(target0) + '\n')

    if project.template() == Project.pak:
      stream.write('\n')
      stream.write('sync:\n')
      stream.write('\t@echo "Syncing with the depot..."\n')
      stream.write('\t-@p4 sync ')
      if project.vpath():
        stream.write(self.makefileString( project.vpath() ) + dirSeparator )
      stream.write('...\n')
      stream.write('\n')
      stream.write('targz: sync\n')

      if project.vpath():
        dirname = os.path.dirname(project.vpath())
        package = os.path.basename(project.vpath())
      else:
        dirname = '..'
        package = os.path.basename(os.path.getcwd())
      tarfile = os.path.join(os.path.abspath('..'), package + '.tar')
      stream.write('\t@cd ' + self.makefileString( dirname ) + ' ; \\\n')
      stream.write('\techo Tarring ' + package + '... ; \\\n')
      stream.write('\ttar cf ' + self.makefileString(tarfile) + ' ' \
                   + self.makefileString( package + dirSeparator \
                                          + 'configure ' ) \
                   + self.makefileString( package + dirSeparator + 'config' )\
                   + ' \\\n')
      stream.write('\t' + package + dirSeparator + 'config-app ' + package \
                   + dirSeparator + 'Makefile ' + package + dirSeparator \
                   + 'BUGS ' + package + dirSeparator + 'TODO \\\n')
      stream.write('\t' + package + dirSeparator + 'COPYING ' + package \
                   + dirSeparator + 'README; \\\n')
      stream.write('\tfind ' + package + dirSeparator \
                   + 'src -name .moc -prune -o -name .obj -prune -o -name '
                   '.dep -prune -o \\( -name \\*.pro -o -name \\*.h -o -name '
                   '\\*.cc -o -name \\*.c \\) -exec tar rf ' + tarfile \
                   + ' {} \\; ; \\\n')
      stream.write('\tfind ' + package + dirSeparator \
                   + 'shared -name .xvpics -prune -o -name \\*\\~ -prune -o '
                   '-type d -o -exec tar rf ' + tarfile + ' {} \\; ; \\\n')
      stream.write('\techo Compressing ' + package + '.tar... ; \\\n')
      stream.write('\tgzip -f -9 ' + tarfile + '\n')

      stream.write('\n')
      stream.write('help:\n')
      stream.write('\t@echo "make           build"\n')
      stream.write('\t@echo "make clean     clean the build arena"\n')
      stream.write('\t@echo "make make      rebuild the Makefile form the project file"\n')
      stream.write('\t@echo "make sync      synchronize with the Perforce depot"\n')
      stream.write('\t@echo "make targz     create a compressed archive of the sources"\n')
      stream.write('\t@echo "make help      this option"\n')
      return

    if project.hasVariable('GENERICS'):
      stream.write('\n\n')
      stream.write('#----------------------------------------\n')
      stream.write('# Explicit rules & dependencies: generics\n')
      stream.write('#----------------------------------------\n')
      for gen in project.variable( 'GENERICS' ):
        stream.write( '\n' )
        g = gen.fullname()
        d = gen.dirname()
        b = os.path.join( d, gen.basename() )
        i = os.path.join( project.incbdir(), b )
        if project.hasVariable( 'INCLUDE_STATIC' ):
          ist = os.path.join( project.variable( 'INCLUDE_STATIC' )[0], b )
        else:
          ist = i
        s = project.qvppath( g )
        stream.write( unixpath( b + '_gen.c ' ) + unixpath( i + '_gen.h ' ) \
                      + unixpath( i + '_gen_static.h' ) + ':\t' + s + '\n' )
        stream.write( '\t[ -d ' + self.makefileString( unixpath( d ) ) \
                      + ' ] || mkdir -p ' + self.makefileString( d ) + '\n' )
        stream.write( '\t[ ! -f ' + unixpath( g ) + ' ] || $(RM) ' \
                      + unixpath( g ) + '\n' )
        stream.write( '\t$(LN) ' + unixpath( os.path.join( '..', s ) ) + ' ' \
                      + unixpath( g ) + '\n' )
        stream.write( '\t$(PREPROC) ' + self.makefileString( g ) + '\n' )
        stream.write( '\t$(RM) ' + unixpath( g ) + '\n' )
        stream.write( '\t[ -d ' + unixpath( os.path.dirname( i ) ) \
                      + ' ] || mkdir -p ' \
                      + self.makefileString( unixpath(
          os.path.dirname( i ) ) ) + '\n' )
        stream.write( '\tmv ' + unixpath( b + '_gen.h ' ) \
                      + unixpath( i + '_gen.h\n' ) )
        stream.write( '\t[ -d ' + unixpath( os.path.dirname( ist ) ) \
                      + ' ] || mkdir -p ' \
                      + unixpath( os.path.dirname( ist ) ) + '\n' )
        stream.write( '\tmv ' + unixpath( b + '_gen_static.h ' ) \
                      + unixpath( ist + '_gen_static.h\n' ) )

    if project.hasVariable('SOURCES_ICE_TO_CPP'):

      stream.write('\n\n')
      stream.write('#--------------------------------------------------\n')
      stream.write('# Explicit rules & dependencies: sources_ice_to_cpp\n')
      stream.write('#--------------------------------------------------\n')
      for ice in project.variable( 'SOURCES_ICE_TO_CPP' ):
        g = ice.fullname()
        d = ice.dirname()
        b = os.path.join( d, ice.basename() )
        i = os.path.join( project.incbdir(), b )
        s = project.qvppath( g )

        stream.write( '\n' )
        stream.write( unixpath( b + '.ice ' ) + ':\t' + s + '\n' )
        if ( project.template() == Project.lib ):
          stream.write( '\t@[ -d ' + self.makefileString( unixpath( d ) ) + ' ] || mkdir -p ' + self.makefileString( d ) + '\n' )
        stream.write( '\t@[ ! -f ' + unixpath( b + '.ice' ) + ' ] || $(RM) ' + unixpath( b + '.ice' ) + '\n' )
        stream.write( '\t@$(LN) ' + unixpath( os.path.join( '..', s ) ) + ' ' + unixpath( b + '.ice' ) + '\n' )

        stream.write( '\n' )
        if ( project.template() == Project.lib ):
          stream.write( unixpath( b + '.cxx ' ) + unixpath( i + '.h ' ) + ':\t' + unixpath( b + '.ice' ) + '\n' )
        else:
          stream.write( unixpath( b + '.cxx ' ) + unixpath( b + '.h ' ) + ':\t' + unixpath( b + '.ice' ) + '\n' )
        if ( project.template() == Project.lib ):
          stream.write( '\t$(SLICE2CPP) --output-dir ' + d + ' --include-dir ' + d + ' ' + self.makefileString( unixpath( b + '.ice' ) ) + '\n' )
        else:
          stream.write( '\t$(SLICE2CPP) ' + self.makefileString( unixpath( b + '.ice' ) ) + '\n' )
        if ( project.template() == Project.lib ):
          stream.write( '\t@[ -d ' + unixpath( os.path.dirname( i ) ) + ' ] || mkdir -p ' + self.makefileString( unixpath( os.path.dirname( i ) ) ) + '\n' )
          stream.write( '\t@mv ' + unixpath( b + '.h ' ) + unixpath( i + '.h\n' ) )

    if project.hasVariable('HEADERS'):
      stream.write('\n\n')
      stream.write('#---------------------------------------\n')
      stream.write('# Explicit rules & dependencies: headers\n')
      stream.write('#---------------------------------------\n')
      for header in project.variable('HEADERS'):
        self.writeHeader( header, project, stream, project.incbdir() )
      if project.hasVariable( 'INCLUDE_STATIC' ):
        incdir = project.variable( 'INCLUDE_STATIC' )[0]
      else:
        incdir = project.incbdir()
      if project.hasVariable( 'HEADERS_STATIC' ):
        for header in project.variable('HEADERS_STATIC'):
          self.writeHeader( header, project, stream, incdir )

    if project.hasVariable('SOURCES') or project.hasVariable('GENERICS') \
           or project.hasVariable('SOURCES_ICE_TO_CPP'):
      stream.write('\n\n')
      stream.write('#---------------------------------------\n')
      stream.write('# Explicit rules & dependencies: sources\n')
      stream.write('#---------------------------------------\n')

      # compile commands are only here if make is invoked with COMP=comp option
      stream.write('\n')
      stream.write('ifdef COMP\n')

      if project.hasVariable('SOURCES'):
        for source in project.variable('SOURCES'):
          self.writeSource( source, project, stream,
                            project.qvppath(source.fullname()) )
      if project.hasVariable('GENERICS'):
        for source in project.variable('GENERICS'):
          s = os.path.join( source.dirname(), source.basename() ) + '_gen'
          self.writeSource( File( s + '.o' ), project, stream, s + '.c' )
      if project.hasVariable('SOURCES_ICE_TO_CPP'):
        for source in project.variable('SOURCES_ICE_TO_CPP'):
          s = os.path.join( source.dirname(), source.basename() )
          self.writeSource( File( s + '.cxx' ), project, stream, s + '.cxx' )

      stream.write('\n')
      stream.write('endif\n')

    if project.hasVariable('SWIG_FILE'):
      swigfile = project.variable('SWIG_FILE')
      if len(swigfile) != 1:
        warning('SWIG_FILE should have only one value, taking last')
      swigfile = swigfile[0]
      stream.write('\n\n')
      stream.write('#---------------------------------------\n')
      stream.write('# Explicit rules & dependencies: swig\n')
      stream.write('#---------------------------------------\n')
      swigfile = project.variable('SWIG_FILE')
      if len(swigfile) != 1:
        warning('SWIG_FILE should have only one value, taking last')
      swigfile = swigfile[0]
      swig_object = swigfile[:-2] + '_wrap.o'
      swig_src = swigfile[:-2] + '_wrap.cc'
      swig_noext = swigfile[:-2] + '_wrap'
      full_swig_file = project.qvppath('$(SWIG_FILE)')
      if project.hasVariable('SWIG_INCLUDES'):
        l = [('-I' + inc) for inc in project.variable('SWIG_INCLUDES')]
        swig_includes = ' '.join(l)
      else:
        swig_includes = ''

      # compile commands are only here if make is invoked with COMP=comp option
      stream.write('\nifdef COMP\n')
      self.writeSource(File(swig_noext), project, stream, swig_src)
      stream.write('\nendif\n')

      stream.write(swig_src + ': ' + project.qvppath('$(SWIG_FILE)') + '\n')
      stream.write('\t(which swig && ')
      stream.write('swig ' + swig_includes+' -python -noproxy -o $(SWIG_SRC)')
      stream.write(' ' + full_swig_file)
      swig_tmp_src = '/tmp/' + swig_src
      # For swig 1.3.24 that does not support Python 2.5 (ml_doc is const)
      stream.write(' && ' + 'cat $(SWIG_SRC) | ')
      stream.write('sed "s/.*char \*\(.*ml_doc.*\)/const char \*\\1/g" | ')
      stream.write(' sed "s/.*char \*name =/const char \*name =/g" > ')
      stream.write(swig_tmp_src + ' && mv ' + swig_tmp_src)
      stream.write(" $(SWIG_SRC) ) || ")
      stream.write("echo 'int main(void) {}' > $(SWIG_SRC) \n\n")

    if project.hasVariable('SIPS'):
      stream.write('\n\n')
      stream.write('#---------------------------------------\n')
      stream.write('# Explicit rules & dependencies: sips\n')
      stream.write('#---------------------------------------\n')

      for source in project.variable('SIPS'):
        dst = project.target() + '.sbf'
        sippro = 'sip_code/sip.pro'
        stream.write( unixpath( dst ) + ':\t' \
                      + string.join( map( lambda x: unixpath( x ),
                                          glob.glob(
          os.path.join( project.qvppath( \
          os.path.dirname( source.fullname() ) ), '*.sip' ) ) ) ) \
                      + ' force\n' )
        # stream.write( '\tif [ -d sip_code ]; then ${RM} -r sip_code; fi\n' )
        # stream.write( '\tmkdir sip_code\n' )
        stream.write( '\tif [ ! -d sip_code ]; then mkdir sip_code; fi\n' )
        stream.write( '\t' + sip_executable + ' ${SIPINCLUDE} -s ".cc" -e ' )
        try:
          import pyqtconfig
          conf = pyqtconfig.Configuration()
          stream.write( conf.pyqt_qt_sip_flags + ' ' )
          del conf
        except:
          print 'warning: pyqtconfig module not found'
          sys.exit( 1 )
          if project.hasVariable( 'SIP_QT_VERSION' ) \
                 and project.variable( 'SIP_QT_VERSION' ):
            stream.write( '-t ${SIP_QT_VERSION} ' )
          if project.hasVariable( 'SIP_PLATFORM' ) \
                 and project.variable( 'SIP_PLATFORM' ):
            stream.write( '-t ${SIP_PLATFORM} ' )
        stream.write( '-c sip_code -b ' + dst + ' ' )
        stream.write( '$(SIP_OPTIONS) ' )
        stream.write( unixpath( project.qvppath(source.fullname() ) ) + '\n' )
        stream.write( '\tif [ ! -d ' + pydir + ' ]; then mkdir ' + pydir \
                      + '; fi\n' )
        srcpy1 = project.target()
        if srcpy1.endswith( 'sip' ):
          srcpy1 = srcpy1[ :-3 ]
        if platform.sipversion()[0] < 4:
          stream.write( '\tmv sip_code/' + project.target() + '.py ' + pydir \
                        + '\n' )
        srcpy = unixpath( project.qvppath( srcpy1 ) )
        stream.write( '\tif [ -d ' + srcpy + ' ]; then ${RM} -r ' \
                      + unixpath( os.path.join( pydir,
                                                os.path.basename( srcpy ) ) ) \
                      + '; ${LN} ' + srcpy + ' ' \
                      + unixpath( os.path.join( pydir, srcpy1 ) ) + '; fi\n' )
        srcpy = unixpath( project.qvppath( srcpy1 + '.py' ) )
        stream.write( '\tif [ -f ' + srcpy + ' ]; then ${RM} ' \
                      + unixpath( os.path.join( pydir,
                                                os.path.basename( srcpy ) ) ) \
                      + '; ${LN} ' + srcpy + ' ' \
                      + unixpath( os.path.join( pydir, srcpy1 + '.py' ) ) \
                      + '; fi\n' )
        stream.write( '\t${RM} makepro.py\n')
        stream.write( '\techo "import sys" > makepro.py\n' )
        stream.write( '\techo "input = sys.argv[1]" >> makepro.py\n' )
        stream.write( '\techo "output = sys.argv[2]" >> makepro.py\n' )
        stream.write( '\techo "import string" >> makepro.py\n' )
        stream.write( '\techo "f = open( input )" >> makepro.py\n' )
        stream.write( '\techo "p = open( output, \'a\' )" >> makepro.py\n' )
        stream.write( '\techo "for line in f.xreadlines():" >> makepro.py\n' )
        stream.write( '\techo "  if line.startswith( \'target\' ):" >> '
                      'makepro.py\n' )
        if platform.system() == OS.solaris:
          nl = '\\\\\\\\n' # on solaris, echo doesn't escape '\n' the same way...
        else:
          nl = '\\n'
        if platform.sipversion()[0] < 4:
          stream.write( '\techo "    line = \'TARGET\' + line[6:-1] ' 
                        '+ \'cmodule' + nl + '\'" >> makepro.py\n' )
        else:
          stream.write( '\techo "    line = \'TARGET\' + line[6:]"' 
                        ' >> makepro.py\n' )
        stream.write( '\techo "  elif line.startswith( \'sources\' ):" >> makepro.py\n' )
        stream.write( '\techo "    line = \'SOURCES\' + line[7:]" >> makepro.py\n' )
        stream.write( '\techo "  elif line.startswith( \'headers\' ):" >> makepro.py\n' )
        stream.write( '\techo "    line = \'HEADERS\' + line[7:]" >> makepro.py\n' )
        stream.write( '\techo "  elif line.startswith( \'moc_headers =\' ):" >> makepro.py\n' )
        stream.write( '\techo "    line = \'HEADERS +=\' + line[13:]" >> makepro.py\n' )
        stream.write( '\techo "  p.write( line )" >> makepro.py\n' )
        stream.write( '\techo "p.close()" >> makepro.py\n' )
        stream.write( '\techo "f.close()" >> makepro.py\n' )
        stream.write( '\techo "TEMPLATE = bundle" > ' + sippro + '\n' )
        stream.write( '\techo "#!include ../../../config-local" >> ' + sippro + '\n' )
        stream.write( '\techo "VERSION = " >> ' + sippro + '\n' )
        stream.write( '\techo "LIBPREFIX = " >> ' + sippro + '\n' )
        if project.hasVariable('LIBS'):
          stream.write( '\techo "LIBS = ' )
          stream.write(self.makefileString( string.join(project.variable('LIBS'))) )
          stream.write( '" >> ' + sippro + '\n' )
        stream.write( '\techo "DESTDIR = ${DESTDIR}" >> ' + sippro + '\n' )
        if project.hasVariable('INCLUDEPATH'):
          stream.write( '\techo "INCLUDEPATH = ' )
          stream.write(self.makefileString( string.join(project.variable('INCLUDEPATH'))) )
          stream.write( '" >> ' + sippro + '\n' )
        if platform.system() == OS.win32:
          stream.write( '\techo "EXTENSION_SHLIB = .pyd" >> ' + sippro + '\n' )
        stream.write( '\tpython ./makepro.py "' + dst + '" "' + sippro + '"\n' )
        makerargs = '-r'
        #if options.vpath() is not None:
        #  makerargs = makerargs + ' -p "' + options.vpath() + '"'
        if options.binbdir() is not None:
          makerargs = makerargs + ' --binbdir "' + os.path.join( '..', options.binbdir() ) + '"'
        # if options.incbdir() is not None:
        #   makerargs = makerargs + ' --incbdir "' + os.path.join( '..', options.incbdir() ) + '"'
        if options.libbdir() is not None:
          makerargs = makerargs + ' --libbdir "' \
          + os.path.join( '..', 
                          os.path.normpath( os.path.join( options.libbdir(), 
                          '..', 'python' ) ) ) + '"'
        stream.write( '\tcd sip_code; maker -o Makefile ' + makerargs + ' "sip.pro"\n' )

      stream.write('\n')

      if len( pythons ) != 0:
        stream.write('\n')
        stream.write('#---------------------------------------\n')
        stream.write('# Explicit rules & dependencies: pythons\n')
        stream.write('#---------------------------------------\n')

        for source in pythons:
          dst = unixpath( os.path.join( pydir, source ) )
          src = unixpath( os.path.join( pysrc, source ) )
          stream.write( unixpath( dst ) + ':\t' + unixpath( src ) + '\n' )
          stream.write( '\tif [ ! -d ' + pydir + ' ]; then mkdir ' + pydir + '; fi\n' )
          stream.write( '\tif [ -h ' + dst + ' ]; then ${RM} ' + dst + '; fi\n' )
          stream.write( '\tif [ -d ' + dst + ' ] && ([ -f ' + src + ' ] || [ -d ' + src + ' ]); then ${LN} ' + src + ' ' + dst + '; fi\n' )
          
        stream.write('\n')


  def writeHeader( self, header, project, stream, incdir=None ):
    if incdir:
      stream.write('\n')
      # c'est horrible de mettre la connaissance que project.incbdir()
      # et project.qvppath(header.fullname()) commencent par ../.. mais
      # ca devient vraiment complique sinon
      # (denis) Tellement horrible que ca ne marche pas...
      # je rajoute un test
      hfull = project.qvppath(header.fullname())
      if hfull.find( '..' ) == 0:
        target = walkback(header.fullname())
        if target:
          target = os.path.join('..', '..', target)
        else:
          target = os.path.join( '..', '..' )
        target = os.path.join(target, hfull[6:])
      else:
        target = hfull
      symlink =  os.path.normpath( os.path.join(incdir, header.fullname()) )
      if platform.system() == OS.win32:
        stream.write(self.makefileString( unixpath(symlink) ) + ':\t' + unixpath( target ) + '\n')
      else:
        stream.write(self.makefileString( unixpath(symlink) ) + ':\n')
      d = os.path.dirname(symlink)
      if d:
        stream.write('\t@[ -d ' + unixpath( d ) + ' ] || mkdir -p ' + unixpath( d ) + '\n')
      # do not break other builds relying on this library
      if platform.system() == OS.win32:
        stream.write('\t@[ ! -f ' + unixpath( symlink ) + ' ] || $(RM) ' + unixpath( symlink ) + '\n')
        stream.write('\t@$(LN) ' +  unixpath( target ) + ' ' + unixpath( symlink ) + '\n')
      else:
        stream.write('\t@[ -h ' + unixpath( symlink ) + ' ] || $(LN) ' +  unixpath( target ) + ' ' + unixpath( symlink ) + '\n')
    if File(project.vppath(header.fullname())).moc():
      stream.write('\n')
      stream.write('ifdef COMP\n')
      # rule to build the MOC file from the header file
      dependency = project.qvppath(header.fullname())
      stream.write( unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + ': ' + unixpath( dependency ) + '\n' )
      if header.dirname():
        stream.write('\t@[ -d ' + unixpath( header.dirname() ) + ' ] || mkdir -p ' + unixpath( header.dirname() ) + '\n')
      #stream.write('\t$(MOC) -o $@ ' + self.makefileString( dependency ) + '\n')
      if Configuration.qt_version()[0] >= 4:
        stream.write('\t$(MOC) $(DEFINES) $(INCPATH) ' )
      else:
        stream.write('\t$(MOC) ' )
      stream.write('-o ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + ' ' + unixpath( dependency ) + '\n')
      # rule to build the dependency file from the MOC file
      stream.write( unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.d') ) + ': ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + '\n')
      if header.dirname():
        stream.write('\t@[ -d ' + unixpath( header.dirname() ) + ' ] || mkdir -p ' + unixpath( header.dirname() ) + '\n')
      # delete dependency file and temporary file
      stream.write('\t@$(RM) $@ $@.tmp\n')
      # tell the preprocessor to output the dependencies into the temporary file
      m = project.variable('CXXFLAGS_DEPS')
      if type(m) in (types.ListType, types.TupleType):
        m = string.join(m)
      else:
        m = str(m)
      stream.write('\t@echo "$(CXX) ' + m + ' $(CXXFLAGS) $(DEFINES) -DCARTO_MOC_SOURCE $(INCPATH) ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + ' > $@"\n')
      stream.write('\t@$(CXX) ' + m + ' $(CXXFLAGS) $(DEFINES) -DCARTO_MOC_SOURCE $(INCPATH) ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + ' > $@.tmp  || ( $(RM) $@.tmp && exit 1 )\n')
      # postprocessing temporary file into dependency file can't fail...
      dirname = header.dirname()
      if dirname != '':
        dirname += dirSeparator
      stream.write('\t@sed -e \'s/^#.*$$//; s#^\\(.*\\)\\.o[ ]*:#' + dirname + '\\1.o $@: #; s#[ ]/usr[^ ]*# #g; /^[ ]*\\\\/d\' $@.tmp > $@\n')
      # delete temporary file
      stream.write('\t@$(RM) $@.tmp\n')
      # include the dependency file
      stream.write('-include ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.d') ) + '\n')
      # rule to build the object file from the MOC file
      stream.write( unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.o') ) + ': ' + unixpath( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + '\n')
      if header.dirname():
        stream.write('\t@[ -d ' + unixpath( header.dirname() ) + ' ] || mkdir -p ' + unixpath( header.dirname() ) + '\n')
      stream.write('\t$(CXX) -c $(CXXFLAGS)')
      if project.warn():
        stream.write(' $(CXXFLAGS_WARN_ON)')
      else:
        stream.write(' $(CXXFLAGS_WARN_OFF)')
      if project.thread():
        stream.write(' $(CXXFLAGS_THREAD)')
      if project.template() == Project.lib:
        stream.write(' $(CXXFLAGS_SHLIB)')
      stream.write(' $(DEFINES) -DCARTO_MOC_SOURCE $(INCPATH) -o $@ ' + self.makefileString( os.path.join(header.dirname(), 'moc_' + header.basename() + '.cc') ) + '\n')
      stream.write('endif\n')

  def writeSource( self, source, project, stream, origsrc ):
    if File(project.vppath(source.fullname())).lang() == File.Cpp:
      stream.write('\n')
      # rule to build the dependency file from the source file
      stream.write( self.makefileString( unixpath( os.path.join(source.dirname(), source.basename() + '.d') ) ) + ': ' + self.makefileString( unixpath( origsrc ) ) + '\n')
      if source.dirname():
        stream.write('\t@[ -d ' + self.makefileString( unixpath( source.dirname() ) ) + ' ] || mkdir -p ' + self.makefileString( unixpath( source.dirname() ) ) + '\n')
      # delete dependency file and temporary file
      stream.write('\t@$(RM) $@ $@.tmp\n')
      m = project.variable('CXXFLAGS_DEPS')
      if type(m) in (types.ListType, types.TupleType):
        m = string.join(m)
      else:
        m = str(m)
      # tell the preprocessor to output the dependencies into the temporary file
      stream.write('\t@echo "$(CXX) ' + m + ' $(CXXFLAGS)')
      if project.thread():
        stream.write(' $(CXXFLAGS_THREAD)')
      stream.write(' $(DEFINES) $(INCPATH) ' + self.makefileString( unixpath( origsrc ) ) + ' > $@"\n')
      stream.write('\t@$(CXX) ' + m + ' $(CXXFLAGS)')
      if project.thread():
        stream.write(' $(CXXFLAGS_THREAD)')
      stream.write(' $(DEFINES) $(INCPATH) ' + self.makefileString( unixpath( origsrc ) ) + ' > $@.tmp || ( $(RM) $@.tmp && exit 1 )\n')
      # postprocessing temporary file into dependency file can't fail...
      dirname = source.dirname()
      if dirname != '':
        dirname += dirSeparator
      stream.write('\t@sed -e \'s/^#.*$$//; s#^\\(.*\\)\\.o[ ]*:#' + dirname + '\\1.o $@: #; s#[ ]/usr[^ ]*# #g; s#[ ]/opt[^ ]*# #g; /^[ ]*\\\\/d\' $@.tmp > $@\n')
      # delete temporary file
      stream.write('\t@$(RM) $@.tmp\n')
      # include the dependency file
      stream.write('-include ' + unixpath( os.path.join(source.dirname(), source.basename() + '.d') ) + '\n')
      # rule to build the object file from the source file
      stream.write( self.makefileString( unixpath( os.path.join(source.dirname(), source.basename() + '.o') ) ) + ': ' + self.makefileString( unixpath( origsrc ) ) + '\n')
      if source.dirname():
        stream.write('\t@[ -d ' + self.makefileString( unixpath( source.dirname() ) ) + ' ] || mkdir -p ' + self.makefileString( unixpath( source.dirname() ) ) + '\n')
      stream.write('\t$(CXX) -c $(CXXFLAGS)')
      if project.warn():
        stream.write(' $(CXXFLAGS_WARN_ON)')
      else:
        stream.write(' $(CXXFLAGS_WARN_OFF)')
      if project.thread():
        stream.write(' $(CXXFLAGS_THREAD)')
      if project.template() in ( Project.lib, Project.sip, Project.swig ):
        stream.write(' $(CXXFLAGS_SHLIB)')
      stream.write(' $(DEFINES) $(INCPATH) -o $@ ' + self.makefileString( unixpath( origsrc ) ) + '\n')
    else:
      stream.write('\n')
      # rule to build the dependency file from the source file
      stream.write(unixpath( os.path.join(source.dirname(), source.basename() + '.d') ) + ': ' + unixpath( origsrc ) + '\n')
      if source.dirname():
        stream.write('\t@[ -d ' + unixpath( source.dirname() ) + ' ] || mkdir -p ' + unixpath( source.dirname() ) + '\n')
      # delete dependency file and temporary file
      stream.write('\t@$(RM) $@ $@.tmp\n')
      m = project.variable('CFLAGS_DEPS')
      if type(m) in (types.ListType, types.TupleType):
        m = string.join(m)
      else:
        m = str(m)
      # tell the preprocessor to output the dependencies into the temporary file
      stream.write('\t@echo "$(CC) ' + m + ' $(CFLAGS)')
      if project.thread():
        stream.write(' $(CFLAGS_THREAD)')
      stream.write(' $(DEFINES) $(INCPATH) ' + unixpath( origsrc ) + ' > $@"\n')
      stream.write('\t@$(CC) ' + m + ' $(CFLAGS)')
      if project.thread():
        stream.write(' $(CFLAGS_THREAD)')
      stream.write(' $(DEFINES) $(INCPATH) ' + unixpath( origsrc ) + ' > $@.tmp || ( $(RM) $@.tmp && exit 1 )\n')
      # postprocessing temporary file into dependency file can't fail...
      dirname = source.dirname()
      if dirname != '':
        dirname += dirSeparator
      stream.write('\t@sed -e \'s/^#.*$$//; s#^\\(.*\\)\\.o[ ]*:#' + dirname + '\\1.o $@:#; s#[ ]/usr[^ ]*# #g; s#[ ]/opt[^ ]*# #g; /^[ ]*\\\\/d\' $@.tmp > $@\n')
      # delete temporary file
      stream.write('\t@$(RM) $@.tmp\n')
      # include the dependency file
      stream.write('-include ' + unixpath( os.path.join(source.dirname(), source.basename() + '.d') ) + '\n')
      # rule to build the object file from the source file
      stream.write(unixpath( os.path.join(source.dirname(), source.basename() + '.o') ) + ': ' + unixpath( origsrc ) + '\n')
      if source.dirname():
        stream.write('\t@[ -d ' + unixpath( source.dirname() ) + ' ] || mkdir -p ' + unixpath( source.dirname() ) + '\n')
      stream.write('\t$(CC) -c $(CFLAGS)')
      if project.warn():
        stream.write(' $(CFLAGS_WARN_ON)')
      else:
        stream.write(' $(CFLAGS_WARN_OFF)')
      if project.thread():
        stream.write(' $(CFLAGS_THREAD)')
      if project.template() in ( Project.lib, Project.sip, Project.swig ):
        stream.write(' $(CFLAGS_SHLIB)')
      stream.write(' $(DEFINES) $(INCPATH) -o $@ ' + unixpath( origsrc ) + '\n')

# -----------------------------------------------------------------------------
# 
#         Il ne reste plus qu'�instancier les objets n�essaires pour d�ecter
#         la plateforme cible, tenir compte des options de la ligne de commande,
#         lire le fichier de projet et �rire le Makefile correspondant.
# 
# -----------------------------------------------------------------------------

platform = Platform()
options = Options()

def execute( argv ):
  options.parse(argv, platform)

  platform.setOptions(options)

  project = Project()
  project.setOptions(options)
  project.setSpecs(platform)
  project.read(options.project(), platform)

  if options.targetkludge():
    if options.output():
      try:
        stream = open(options.output(), 'w')
        stream.write(project.target() + '\n')
        stream.close()
      except IOError, (errno, strerror):
        warning(strerror, options.output())
        sys.exit(1)
    else:
      stream.write(project.target() + '\n')
  else:
    makefile = UnixMakefile()
    if options.output():
      try:
        stream = open(options.output(), 'w')
        makefile.write(project, platform, stream)
        stream.close()
      except IOError, (errno, strerror):
        warning(strerror, options.output())
        sys.exit(1)
    else:
      makefile.write(project, platform)
  return project

if __name__ == '__main__':
  execute( sys.argv )
